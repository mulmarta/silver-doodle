% !TEX root = main.tex
% !TeX spellcheck = en_US
\section{Multi-Message Multi-Recipient PKE}\label{sec:mmpke}
We first recall the syntax of mmPKE from \cite{PKC:BelBolSta03}. At a high level, mmPKE is standard encryption that
supports batching a number of encryption operations together, in order to improve efficiency.\footnote{The majority of
  works on mmPKE uses a different syntax, where there is no $\mmpkeExt$ and instead $\mmpkeEnc$ outputs a vector of
  individual ciphertexts. Since $\mmpkeExt$ is deterministic, the syntaxes are equivalent.}

\begin{definition}[\mmPKE]
  A Multi-Message Multi-Receiver Public Key Encryption (mmPKE) scheme $\mmPKE = \allowbreak(\mmpkeKeyGen,\allowbreak \mmpkeEnc,\allowbreak \mmpkeDec, \mmpkeExt)$ consists of the following four algorithms:
  \begin{description}[align=left, nosep]
  \item[]$\mmpkeKeyGen \getsl (\mmpkepk, \mmpkesk)$: Generates a new key pair.
  \item[]$\mmpkeEnc(\vec{\mmpkepk}, \vec{m})\getsl C$: On input of a vector of
    public keys $\vec{\mmpkepk}$ and a vector of messages $\vec{m}$ of the same length, outputs a \emph{multi-recipient ciphertext} $C$ encrypting each message in $\vec{m}$ to the corresponding key in $\vec{\mmpkepk}$.
  \item[]$\mmpkeExt(C, i)\rightarrow c_i$: A deterministic function. On input of a multi-recipient ciphertext $C$ and a position index $i$, outputs an \emph{individual ciphertext} $c_i$ for the $i$-th recipient.
  \item[]$\mmpkeDec(\mmpkesk,c)\rightarrow m\vee\bot$: On input of an individual ciphertext $c$ and a secret key $\mmpkesk$, outputs either the decrypted message $m$ or, in case decryption fails, $\bot$.
  \end{description}
\end{definition}

\subsection{Security with Adaptive Corruptions}
Our security notion for \mmPKE, called $\mmindrcca$, requires indistinguishability in the presence of active adversaries who can adaptively corrupt secret keys of recipients. The notion builds upon the (strengthened) IND-CCA security of \mmPKE from \cite{ASIACCS:PinPoeSch14}, but there are two important differences: First, \cite{ASIACCS:PinPoeSch14} does not consider corruptions. Second, instead of CCA, we define the slightly weaker notion of Replayable CCA (RCCA). Roughly, RCCA \cite{C:CanKraNie03} is the same as CCA except modifying a ciphertext so that it encrypts the exact same message is not considered an attack. RCCA security is implied by CCA security.

We note that an almost identical security definition was presented in parallel by Hashimoto
et.al.\cite{hashimoto2021cmpke}. However, they only consider multi-recipient PKE (mPKE), where all
recipients receive the same message.

\mmindrcca is similar to
RCCA security of regular encryption in the multi-user setting. The main difference is that the challenge ciphertext is computed by encrypting one of two \emph{vectors} of messages $\vec m_0^*$ and $\vec m_1^*$ under a \emph{vector} of public keys $\vec\mmpkepk^*$.
The vector $\vec\mmpkepk^*$ is chosen by the adversary and can contain keys generated by the challenger as well as
arbitrary keys. The adversary also gets access to standard decrypt and corrupt oracles for each recipient.
%
To disable trivial wins, we require that  $\vec m_0^*$ and $\vec m_1^*$ have equal lengths and that if the $i$-th key in $\vec\mmpkepk^*$ is corrupted, then the $i$-th components of $\vec m_0^*$ and $\vec m_1^*$ are identical. Moreover, we require that the for each $i$, the lengths of the $i$-th components of  $\vec m_0^*$ and $\vec m_1^*$ are the same.

The last requirement means that a secure mmPKE scheme may leak the lengths of components of encrypted vectors. We note that \saik is also secure when instantiated with an mmPKE scheme that leaks more (see \cref{sec:mmowrcca}), e.g. whether two messages in a vector are the same.
%
%
% for other schemes it might include
%whether two consecutive messages are identical (the latter is still sufficient for \saik, cee \cref{sec:mmowrcca}).
%
The formal definitions are in \cref{app:mmpke}.
% whenever a key in $\vec\mmpkepk^*$ is generated by the adversary or corrupted, the corresponding messages in $\vec m_0^*$ and $\vec m_1^*$ must be the same. Moreover, the decryption oracle for receiver $i$ outputs a special symbol \literal{test} if the plaintext is receiver $i$'s message in either $\vec m_0^*$ or $\vec m_1^*$ (this is the standard way to define RCCA).

% Finally, the notion is parameterized by the leakage function $\leak(\vec m)$ which formalizes information about a vector $\vec m$ leaked by the encryption function. In this work, we only use the standard leakage that would result from using regular encryption in parallel, that is, $\leak(\vec m)$ outputs the length of each element of $\vec m$.
% However, we note that \saik is still secure if \mmPKE leaks more information, such as relations between elements of $\vec m$ (formally, one-way RCCA is implied even by \mmindrcca with larger leakage; see \cref{sec:mmowrcca}).

\subsection{Construction}
The mmPKE of~\cite{ASIACCS:PinPoeSch14} is straightforward. It requires a
data encapsulation scheme $\dem$, a hash $H$ and a group $\Grp$ of prime order $p$ generated by $g$.\footnote{In \saik we can instantiate $\dem$ with an off-the-shelf
AEAD such as AES-GCM and $H$ with HKDF.} Recall that
ElGamal encryption of $m$ to public key $g^x$ requires sampling coins $r$ to
obtain ciphertext $(g^r, \dem(k_m, m))$ where $k_m = H(g^{rx}, g^x)$. The
mmPKE variant reuses coins $r$ from the first ElGamal ciphertext to encrypt
all subsequent plaintexts. Thus, the final ciphertext has the form $(g^r,
\dem(k_1, m_1), \dem(k_2, m_2),$ $\ldots)$ where $k_i = H(g^{rx_i},
g^{x_i})$ for all $i$. We call the construction $\dhmmpke[\Grp,\allowbreak g,\allowbreak p,\allowbreak \dem, H]$; a formal description is in \cref{sec:app-mmpke}.

\paragraph{Optimizing for Short Messages.}
Normally, when messages $m$ can have arbitrary size, a sensible mmPKE would use a
KEM{\textbackslash}DEM style construction to avoid having to re-encrypt $m$
multiple times. In other words, for each $m$ in the encrypted vector, we choose a fresh key $k'_m$
for an AEAD and encrypt $m$ with $k'_m$. Then use the mmPKE of
\cite{ASIACCS:PinPoeSch14} to encrypt $k'_m$ to each public key receiving $m$.
However, since the secrets encrypted in \saik have the same length as AEAD
keys, in our case it is more efficient to encrypt the secrets directly.

\paragraph{Tight security bound.}
In \cref{sec:app-mmpke}, we prove the following upper bound on the advantage of any adversary against the \mmPKE from \cite{ASIACCS:PinPoeSch14}. Our bound is tighter than the bound that follows from the straightforward adaptation of the bound from \cite{ASIACCS:PinPoeSch14} (i.e. using the hybrid argument and guessing the uncorrupted key). In particular, that bound would depend (linearly) on the total number of public keys, which may get very large. In contrast, our bound depends only on the number of corrupted keys and the length of encrypted vectors.

\begin{restatable}{theorem}{mmpkeSecurity}\label{thm:mmpke_security}
  Let $\Grp$ be a group of prime order $p$ with generator $g$, let $\dem$ be a data encapsulation mechanism and let
  $\mmPKE = \dhmmpke[\Grp, g, p, \dem, H]$. For any adversary $\Adv$ and any $N \in \N$, there exist adversaries $\Bdv[1]$ and $\Bdv[2]$ with runtime roughly the same as $\Adv$'s s.t.
  \begin{align*}
    \textnormal{Adv}^{\mmindrcca}_{\mmPKE, N}(& \Adv) \leq \adv{\indrcca}{\dem}({\Bdv[2]}) \\
                                              &+2n\cdot(e^2q_c \adv{\sdh}{(\Grp, g, p)}({\Bdv[1]}) + \frac{q_{d_1}}{p} + \frac{q_{h}}{p}),
  \end{align*}
  where $H$ is a random oracle, $e$
  is the Euler number, $n$ is the length of the challenge vector, and $q_{d_1}$, $q_c$ and $q_h$ are the number of queries to the decrypt and corrupt oracles and the random oracle, resp.
\end{restatable}

\begin{remark}
Some practical applications of Diffie-Hellman, most notably \textsc{Curve25519} and \textsc{Curve448} \cite{rfc7748}, implement a Diffie-Hellman operation that is not exponentiation in a prime-order group. Such operations can be formalized as so-called nominal groups \cite{EC:ABHKLR21_2}. In \cref{app:nominal_groups}, we generalize and prove \cref{thm:mmpke_security} for nominal groups. In particular, this means that \dhmmpke is secure if instantiated with \textsc{Curve25519} and \textsc{Curve448}.
\end{remark}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
