% !TEX root = main.tex
% !TeX spellcheck = en_US
\section{Security of \saik}\label{sec:bgm_prot_proof}
The security predicates for \saik are defined in \cref{fig:safe}. See \cref{sec:saik-sec-int} for the intuition. The stronger version of the predicates that is not achieved by \saik skips the code in \BoxedString{boxes}, while the weaker version includes the whole code. In \cref{sec:ext-sec-predicates} we sketch how to modify \saik to achieve the stronger version.

\input{fig_cgka_predicates}

For the \mmPKE scheme we assume a security property called \mmowrcca, defined in \cref{sec:mmowrcca}. The notion is strictly weaker than \mmindcca; in \cref{sec:mmowrcca} we prove the implication.

%\newcommand{\ucideal}{\textnormal{\textsc{ideal}}}
%\newcommand{\ucreal}{\textnormal{\textsc{real}}}
\begin{restatable}{theorem}{itkSec}\label{thm:itk_secure_conf}
Let $\funcCGKA$ be the CGKA functionality with predicates \KwConf{} and \KwAuth{} defined in \cref{fig:safe}. Let $\saik$ be instantiated with schemes \mmPKE, \sigscheme and \mac, and with the \hkdf functions modelled as a random oracle \hash.
Let $\Adv$ be any environment. Denote the output of $\Adv$ from the real execution with \saik and the hybrid functionality $\funcPKI$ from \cref{fig:aks} as $\ucreal_{\saik, \funcPKI}(\Adv)$ and the output of $\Adv$ from the ideal execution with $\funcCGKA$ and a simulator $\ucsim$ as $\ucideal_{\funcCGKA, \ucsim}(\Adv)$.
%
There exists a simulator $\ucsim$ and adversaries $\Bdv[1]$ to $\Bdv[4]$ such that
\begin{align*}
	\Pr[\ucideal&_{\funcCGKA, \ucsim}(\Adv) = 1] - \Pr\left[\ucreal_{\saik, \funcPKI}(\Adv) = 1\right] \leq \\
	&\textnormal{Adv}^{\gamefont{CR}}_{\hash}(\Bdv[1]) \\
	% confidentiality
	+\ & q_e^2(q_e+1) \log(q_n) \cdot\textnormal{Adv}^\mmowrcca_{\mmPKE,q_e\log(q_n),q_n}(\Bdv[2]) \\
	% authenticity asym
	+\ & 2q_e\cdot \textnormal{Adv}^{\ufcma}_\sigscheme(\Bdv[3]) \\
	+\ & q_e \cdot \textnormal{Adv}^{\ufcma}_\mac(\Bdv[4]) + 3q_hq_e^2(q_e+1)/2^\kappa,
\end{align*}
where $q_e$, $q_n$ and $q_h$ denote bounds on the number of epochs, the group size and the number of $\Adv$'s queries to the random oracle modelling the $\hash$, respectively.
%  In the reductions, the $\hkdf$ functions are modelled as a random oracle.
\end{restatable}

\subsection{Proof Outline}
Int the remaining subsections we prove \cref{thm:itk_secure_conf}.

The proof proceeds in a sequence of hybrids, transitioning from the real to the ideal world. Hybrid 1 differs from the real world only syntactically. That is, the environment $\Adv$ interacts with a dummy CGKA functionality $\funcCGKA^1$ which allows the simulator to set all outputs. This means that $\funcCGKA^1$ gives no security guarantees. The next three hybrids introduce the guarantees of consistency, confidentiality and authenticity, one by one. More precisely, in hybrid 2, $\Adv$ interacts with $\funcCGKA^2$ which is the same as $\funcCGKA$, except it uses \KwConf{} and \KwAuth{} set to false. In particular, this means that $\funcCGKA^2$ builds a history graph, enforces its consistency and uses it to compute outputs. In hybrid 3, $\Adv$ interacts with $\funcCGKA^3$ which uses the original \KwConf{} predicate, and in hybrid 4 it interacts with $\funcCGKA^4$ which also uses the original \KwAuth{} predicate. Notice that $\funcCGKA^4$ is $\funcCGKA$.

In the next subsections, we define the hybrids and show that each pair of consecutive hybrids is indistinguishable for $\Adv$. Intuitively, each such statement means that \saik provides the introduced security guarantee.

\begin{description}
  \item[Hybrid 1.] This is the experiment $\ucideal_{\funcCGKA^1, \ucsim^1}$ where the dummy functionality $\funcCGKA^1$ sends all inputs to the simulator $\ucsim^1$ and allows it to set all outputs. $\ucsim^1$ executes \saik.
%differs from $\funcCGKA$ in that it allows the simulator to choose each output, skips all \KwAss{} statements and uses $\KwConf{}=\KwAuth{}=\false$. It interacts with the simulator $\ucsim^1$ who computes outputs according to the protocol, always sends $\hgnodeid=0$ and $\textit{ack}=\true$, and interprets values in injected messages ($\hgorig'$ etc.) as $\bot$. %The PKI functionality is fully emulated by $\ucsim^1$.
\end{description}

\subsection{\saik Guarantees Consistency}\label{sec:protsec3}
The following hybrid introduces consistency.
\begin{description}
  \item[] {\bf Hybrid 2: $\ucideal_{\funcCGKA^2, \ucsim^2}$.} The functionality $\funcCGKA^2$ is the same as $\funcCGKA$ except it uses $\KwConf{}=\KwAuth{}=\false$. The simulator $\ucsim^2$ is described later in this section.
\end{description}

In the reminder of this section, we construct the simulator $\ucsim^2$ and show that hybrids 1 and 2 are indistinguishable.
\begin{theorem}
  For any environment $\Adv$, there exists an adversary $\Bdv$ such that
  \begin{equation*}\normalfont
    \left\lvert\begin{array}{c}
    \Pr\left[\ucideal_{\funcCGKA^2, \ucsim^2}(\Adv) \Rightarrow 1\right] \\- \Pr\left[\ucideal_{\funcCGKA^1,
      \ucsim^1}(\Adv) \Rightarrow 1\right]
    \end{array}\right\lvert
    \leq \textnormal{Adv}^{\gamefont{CR}}_{\hash}(\Bdv) + q_e/2^\kappa,
  \end{equation*}
  where $\hash$ models the \hkdfexp and \hkdfext functions and $q_e$ denotes an upper bound on the number of epochs.
\label{thm:itk1}\end{theorem}

\headingB{The simulator.}
We first describe $\ucsim^2$. In general, it runs \saik just like $\ucsim^1$, only its interaction with the functionality is different. Most importantly, $\funcCGKA^2$ requires that $\ucsim^2$ identifies epochs into which parties transition. Doing this correctly is crucial for proving that \saik guarantees consistency, because $\funcCGKA^2$ enforces it by computing outputs and asserting conditions relative to parties' current epochs. (It must also be done so that we can later prove that \saik guarantees confidentiality and authenticity.)

$\ucsim^2$ identifies epochs by their epoch secrets $\epochSecret$, computed by \saik on Receive and Send. Recall that a party $\id$ transitioning from an epoch $E[1]$ to $E_2$ computes $E_2$'s $\epochSecret$ by hashing $E[1]$'s init secret, the new commit secret (combined into the joiner) generated by $E_2$'s creator and $E_2$'s context. We will show that these values contain enough information for $\epochSecret$ to \emph{uniquely} identify $E_2$. Recall also that the group and init key of $E_2$ are derived from $\epochSecret$.
The simulator is described in more detail in \cref{fig:simu}.

\begin{figure*}[tbp]
\begin{simulatorbox}{\normalsize $\ucsim^2$}{\raggedright
  $\ucsim^2$ keeps a list $\epochSecretVec$, where $\epochSecretVec[\hgnodeid]$ stores the epoch secret identifying epoch $\hgnodeid$. It runs \saik and interacts with $\funcCGKA^2$ as follows:
  \begin{itemize}[itemsep=0pt]
    \item If \saik outputs $\bot$ on Send or Receive, $\ucsim^2$ sends $\textit{ack}$ set to false.
    \item On each Send, $\ucsim^2$ computes the new epoch's $\epochSecret$ and appends it to $\epochSecretVec$. It sends to $\funcCGKA$ the message $C$ computed using \saik.
    \item On each Receive, $\ucsim^2$ first sends to $\funcCGKA$ the values $\hgorig'$, $\hgact'$ from the message. If the receiver is not removed, $\ucsim^2$ sends $\hgnodeid$ into which $\id$ transitions chosen as follows:
    \begin{itemize}[itemsep=0pt,topsep=0pt]
      \item If there is a $\hgnodeid$ s.t. $\epochSecretVec[\hgnodeid]=\epochSecret$, then $\ucsim^2$ sends this (unique) $\hgnodeid$ to $\funcCGKA^2$.
      \item Else, $\ucsim^2$ appends $\hgnodeid$ to $\epochSecretVec$ and sends $\hgnodeid=\bot$ to $\funcCGKA^2$.
    \end{itemize}
    Finally, if a detached root is created and $\funcCGKA^2$ asks for the member set $\hgm'$, $\ucsim^2$ computes it from the new member's ratchet tree.
  \end{itemize}}
\end{simulatorbox}
\caption{The simulator for the proof of the security of \saik.}\label{fig:simu}
\end{figure*}

\headingB{Proof.} We next prove \cref{thm:itk1}. Observe that hybrids 1 and 2 are identical unless one of the following two events occurs in hybrid 2:
\begin{description}
  \item[] $\variable{BreaksCons}$ : Either the output of a party on Receive or Key computed according to $\funcCGKA^2$ and $\ucsim^2$ is different than the output $\ucsim^1$ would compute according to \saik in hybrid 1, or an \KwAss{} condition is false.
  \item[] $\variable{EpidColl}$ : An honestly created epoch has the same $\epochSecret$ as an existing epoch.
\end{description}
Observe that since an honest sender mixes a fresh $\commitSecret$ into the derivation of $\epochSecret$, the probability of $\variable{EpidColl}$ is at most $q_e/2^\kappa$ (where $\kappa$ is the length of all secrets).
It remains to show that if $\Adv$ triggers $\variable{BreaksCons}$, then a reduction $\Bdv$ can extract from a hash collision. (\cref{thm:itk1} follows by the standard difference lemma.)

Let $\Adv$ be any environment and assume that at the end of hybrid 2 with $\Adv$ there are no hash between values hashed by $\ucsim^2$ while running \saik on behalf of honest parties. We show that in this case $\variable{BreaksCons}$ cannot occur. This proves the claim, because if there was a hash collision between values hashed by honest parties, then $\Bdv$ could extract them by emulating $\ucsim^1$.

Observe that if two parties transition to the same epoch $\hgnodeid$, then by definition of $\ucsim^2$ they compute the same $\epochSecret$. Recall that they compute $\epochSecret \gets \hash(\joinerSecret, \groupContext)$ (\cref{fig:prot-helpers2}), where $\groupContext=(\groupId, \treeHash, \id_s\md\hgact)$ (\cref{tab:prot-state}).
Since there are no hash collisions, this means that the parties also agree on the following values:
\begin{enumerate}[label=\alph*)]
  \item The creator $\hg_s$ of $\hgnodeid$, the action $\hgact$ it performed and the public part of the ratchet tree, included in $\treeHash$. This implies agreement on the roster, which is encoded in the tree leaves.
  \item The group key in $\hgnodeid$, derived as $\hash(\epochSecret, \literal{app})$.
\end{enumerate}

Moreover, let $\epochSecret'$ denote the epoch secret of $\hgnodeid$'s parent. We have $\joinerSecret = \hash(\initSecret', \commitSecret)$, where $\initSecret' = \hash(\epochSecret', \literal{init})$ and $\commitSecret$ is freshly chosen for $\hgnodeid$ by its creator. Therefore, parties in $\hgnodeid$ also agree on:\\
\begin{minipage}{\linewidth}~
\begin{enumerate}[label=\alph*),start=3]
  \item The parent epoch $\hgnodeid'$ identified by $\epochSecret'$.
\end{enumerate}
\end{minipage}

\medskip\noindent Observe that the check $\hash(\initSecret', \commitSecret)=\joinerSecret$ is verified by current members transitioning to $\hgnodeid$ but not by joiners. However, joiners implicitly agree with current members on the parent $\hgnodeid'$. That is, if an $\id_r$ joins into $\hgnodeid$, then $\hgnodeid$ has parent $\hgnodeid'$ (unknown to $\id_r$) or no parent at all (for detached roots).

We next show that agreement on a), b) and c) implies that $\variable{BreaksCons}$ does not occur. First, a) and b) imply that all parties joining an epoch $\hgnodeid$ output the same value, all parties transitioning there output the same, and afterwards all output the same key. Second, c) implies that HG is a forest, i.e., each epoch has one parent.

Third, we have to argue that parties' outputs are the same as computed by $\funcCGKA^2$. This is obvious for the key (always chosen by $\ucsim^2$ to match), sender and action. For the member set, we will show that the ratchet tree of parties in an epoch $\hgnodeid$ is consistent with $\hg[\hgnodeid].\hgm$ computed by $\funcCGKA^2$. We use induction on the distance of $\hgnodeid$ to the root. If $\hgnodeid$ is the main root, then the statement is true by definition and if it is a  detached roots, then $\ucsim^2$ chooses $\hgm$ to match the ratchet tree. For any non-root $\hgnodeid$, some party $\id$ must have transitioned there from its parent $\hgnodeid'$ (on Receive or Send). By induction hypothesis, the ratchet tree in $\hgnodeid'$ is consistent with $\hg[\hgnodeid].\hgm$. By agreement on $\hgact$ in a), $\id$ modifies the tree the same way as $\funcCGKA^2$ modifies $\hg[\hgnodeid].\hgm$, which proves the statement.

\subsection{\saik Guarantees Confidentiality}\label{sec:protsec4}
The third hybrid introduces confidentiality of group keys, which is formalized by restoring the original confidentiality predicate of $\funcCGKA$.
\begin{description}
\item[] {\bf Hybrid 3: $\ucideal_{\funcCGKA^3, \ucsim^3}$.} The functionaliy $\funcCGKA^3$ uses the original \KwConf{} predicate from $\funcCGKA$. The simulator $\ucsim^3$ is the same as $\ucsim^2$.
\end{description}

In the remainder of this section, we show that if \mmPKE is \mmowrcca secure, then \saik guarantees confidentiality, that is, that hybrids 2 and 3 are indistinguishable. Formally, we prove the following theorem.
\begin{theorem}

  For any environment $\Adv$, there exists an adversary $\Bdv$ such that
  \normalfont
  \begin{multline*}
    \Pr\left[\ucideal_{\funcCGKA^3, \ucsim^3}(\Adv) \Rightarrow 1\right] - \Pr\left[\ucideal_{\funcCGKA^2,
        \ucsim^2}(\Adv) \Rightarrow 1\right]\\
    \leq 4q_e^2q_h/2^\kappa \\
    + q_e^2\log(q_n)\cdot\textnormal{Adv}^\mmowrcca_{\mmPKE,q_e\log(q_n),q_n}(\Bdv),
  \end{multline*}
  where the $\hkdf$ functions are modeled as a random oracle and where $q_n$, $q_h$ and $q_e$ are upper bounds on, respectively, the group size, the number of $\Adv$'s hash queries and the number of epochs.
\label{thm:hybrid2}\end{theorem}

\headingB{Game-based perspective.}
For better intuition, observe that hybrids 2 and 3 are almost identical. In both experiments, the environment interacts with the CGKA functionality and the same simulator. The only difference is that group keys in confidential epochs are real in hybrid 2 (technically, computed by the simulator according to \saik) and random and independent in hybrid 3 (technically, sampled by $\funcCGKA^3$).
This means that distinguishing between hybrids 2 and 3 can be seen as a typical confidentiality game for CGKA schemes. The adversary in the game corresponds to the environment $\Adv$. The adversary's challenge queries correspond to $\Adv$'s GetKey inputs on behalf of parties in confidential epochs and its reveal-session key queries correspond to $\Adv$'s GetKey inputs in non-confidential epochs. To disable trivial wins, confidential epochs where a random key has been outputted are marked by setting a flag $\hgc$. $\Adv$ and the adversary in the game are not allowed to corrupt if this makes such an epoch non-confidential.

%\headingB{Different secrets of \saik.}
%We briefly recall how different secrets are created by \saik, which is crucial for achieving confidentiality. The process of creating secrets for a new epoch $\hgnodeid$ is visualized in \cref{fig:protsec-pic}.
%%All secrets are derived deterministically from the init secret in $\hgnodeid$'s parent and a fresh secret $s$, sampled by $\hgnodeid$'s creator.
%First, path secrets are derived as a hash chain, starting with a random value picked by $\hgnodeid$'s creator. The root's path secret, called the commit secret, is then hashed with the init secret of $\hgnodeid$'s parent to derive the joiner secret. The joiner is hashed with $\hgnodeid$'s context to derive $\hgnodeid$'s epoch secret, from which $\hgnodeid$'s init secret and group key are derived.
%We use
%\begin{figure}[htb]
%\input{prot_proof_pic}
%\label{fig:protsec-pic}\caption{A visualization of different secrets created by \saik. Directed edges correspond to hash evaluations with different labels.}
%\end{figure}

\headingB{Key Graphs.}
A key graph visualizes different secrets created in an execution of \saik and hash relations between them. Each node in the graph corresponds to a secret, e.g. the group key in epoch $5$, and has assigned its value. The directed edges are interpreted as follows: the value of a node is the hash of the values of all its in-neighbors with an appropriate label. If a node has many out-neighbors, then the value of each out-neighbor is computed by hashing with a different label (i.e., the values of out-neighbors are domain-separated).
Values of source nodes are either chosen at random by the protocol or injected by the adversary.
The key-graph nodes are partitioned by epochs: Secrets of an epoch $\hgnodeid$ are those created when $\hgnodeid$ is created.
We distinguish two types of secrets: \emph{group secrets} which include the init, joiner and epoch secrets as well as the group key, and \emph{individual secrets}, which include path secrets, the last being the commit secret.
An example key graph is given below. We removed membership secrets for simplicity. Note that the epochs 6 and 7 are created in parallel, that is, we have a group fork.

\begin{center}\scalebox{.8}{
\begin{tikzpicture}\scriptsize
  \def\nodeSep{3em}
  \def\descSep{1pt}
  \def\epoSep{16em}
  \tikzstyle{sec}=[fill=black,circle,minimum size=.15cm,inner sep=0pt,outer sep=0pt]
  \tikzstyle{desc}=[draw=none,rectangle,inner sep=0pt,outer sep=0pt,minimum height=.7em]
  \tikzstyle{every path}=[-{Latex[length=1.5mm]}]

  \node[sec] (sj1) at (0,-7em) {}; \node[desc,above=\descSep of sj1] (dj1) {\smash{joiner}};
  \node[sec,right=\nodeSep of sj1] (se1) {}; \node[desc,above=\descSep of se1] (de1) {\smash{epoch}};
%    \node[sec] (se1) at (0,0) {}; \node[desc,above=\descSep of se1] (de1) {\smash{epoch}};

  \node[sec,above right=\nodeSep of se1] (sgk1) {}; \node[desc,above=\descSep of sgk1] (dgk1) {\smash{group key}};
  \node[sec,right=\nodeSep of se1] (si1) {}; \node[desc,above=\descSep of si1] (di1) {\smash{init}};

  \node[sec,below=\nodeSep of sj1] (sc1) {}; \node[desc,left=\descSep of sc1] (dc1) {\smash{commit}};
%    \node[sec,below=\nodeSep of se1] (sc1) {}; \node[desc,left=\descSep of sc1] (dc1) {\smash{commit}};

  \node[sec,below=\nodeSep of sc1] (sp11) {}; \node[desc,left=\descSep of sp11] (dp11) {\smash{path}};
  \node[sec,below=\nodeSep of sp11] (sp12) {}; \node[desc,left=\descSep of sp12] (dp12) {\smash{path}};
  \node[draw=none,anchor=west,rectangle,right=1.5*\nodeSep of sp12,text=black!60] (epo1) {epoch 5};

  \draw (sj1) -- (se1);

  \draw (se1) -- (sgk1);
  \draw (se1) -- (si1);

  \draw (sc1) -- (sj1);
%    \draw (sc1) -- (se1);

  \draw (sp11) -- (sc1);
  \draw (sp12) -- (sp11);
  \draw (-6em,-7em) -- (sj1);

 \begin{scope}[on background layer]
    \node[
      rectangle,draw=black!15,fill=black!5,rounded corners=1ex,inner sep=4pt,
      fit=(dc1) (dgk1.north) (epo1) (sp12),
      ] {};
 	\end{scope}

  \node[sec] (sj3) at (\epoSep,-13em) {}; \node[desc,above=\descSep of sj3] (dj3) {\smash{joiner}};
  \node[sec,right=\nodeSep of sj3] (se3) {}; \node[desc,above=\descSep of se3] (de3) {\smash{epoch}};
  \node[sec,above right=\nodeSep of se3] (sgk3) {}; \node[desc,above=\descSep of sgk3] (dgk3) {\smash{group key}};
  \node[sec,right=\nodeSep of se3] (si3) {}; \node[desc,above=\descSep of si3] (di3) {\smash{init}};
  \node[sec,below=\nodeSep of sj3] (sc3) {}; \node[desc,left=\descSep of sc3] (dc3) {\smash{commit}};
  \node[sec,below=\nodeSep of sc3] (sp31) {}; \node[desc,left=\descSep of sp31] (dp31) {\smash{path}};
%    \node[sec,below=\nodeSep of sp31] (sp32) {}; \node[desc,left=\descSep of sp32] (dp32) {\smash{path}};
  \node[draw=none,anchor=west,rectangle,right=1.5*\nodeSep of sp31,text=black!60] (epo3) {epoch 7};

  \draw (si1) -- (sj3);
  \draw (sj3) -- (se3);
  \draw (se3) -- (sgk3);
  \draw (se3) -- (si3);
  \draw (sc3) -- (sj3);
  \draw (sp31) -- (sc3);
%    \draw (sp32) -- (sp31);

 \begin{scope}[on background layer]
    \node[
      rectangle,draw=black!15,fill=black!5,rounded corners=1ex,inner sep=4pt,
      fit=(dc3) (dgk3.north) (epo3),
      ] {};
 	\end{scope}

  \node[sec] (sj2) at (\epoSep,0) {}; \node[desc,above=\descSep of sj2] (dj2) {\smash{joiner}};
  \node[sec,right=\nodeSep of sj2] (se2) {}; \node[desc,above=\descSep of se2] (de2) {\smash{epoch}};
  \node[sec,above right=\nodeSep of se2] (sgk2) {}; \node[desc,above=\descSep of sgk2] (dgk2) {\smash{group key}};
  \node[sec,right=\nodeSep of se2] (si2) {}; \node[desc,above=\descSep of si2] (di2) {\smash{init}};
  \node[sec,below=\nodeSep of sj2] (sc2) {}; \node[desc,left=\descSep of sc2] (dc2) {\smash{commit}};
  \node[sec,below=\nodeSep of sc2] (sp21) {}; \node[desc,left=\descSep of sp21] (dp21) {\smash{path}};
%    \node[sec,below=\nodeSep of sp21] (sp22) {}; \node[desc,left=\descSep of sp22] (dp22) {\smash{path}};
  \node[draw=none,anchor=west,rectangle,right=1.5*\nodeSep of sp21,text=black!60] (epo2) {epoch 6};

  \draw (si1) -- (sj2);
  \draw (sj2) -- (se2);
  \draw (se2) -- (sgk2);
  \draw (se2) -- (si2);
  \draw (sc2) -- (sj2);
  \draw (sp21) -- (sc2);
%    \draw (sp22) -- (sp21);

 \begin{scope}[on background layer]
    \node[
      rectangle,draw=black!15,fill=black!5,rounded corners=1ex,inner sep=4pt,
      fit=(dc2) (dgk2.north) (epo2) (sp21),
      ] {};
 	\end{scope}


\end{tikzpicture}}
\end{center}

Note that in case of injections the values of nodes may not be unique. However, the values of epoch secrets uniquely identify epochs. Note also that the values of group secrets of $\hgnodeid$ appear only in the states of parties in $\hgnodeid$. On the other hand, \mmPKE keys derived from path secrets of $\hgnodeid$ appear in ratchet trees stored by parties in multiple epochs.

\headingB{Bad events.}
Let $\Adv$ be any environment. The goal is to show that $\Adv$ cannot distinguish the real group keys of confidential epochs it sees in hybrid 2 from random and independent keys in hybrid 3. Since epochs in detached trees are not confidential, in the remainder of the proof we only consider epochs in the main history-graph tree.

Observe that there are only two dependencies between the real group key $\applicationSecret$ of an epoch $\hgnodeid$ and the rest of the experiment: $\applicationSecret$ is stored by parties in $\hgnodeid$ and it is the hash of $\hgnodeid$'s unique epoch secret $\epochSecret$. If $\hgnodeid$ is confidential, then no party in $\hgnodeid$, i.e., no party storing $\applicationSecret$ is corrupted. Therefore, unless $\Adv$ inputs $\epochSecret$ to the RO, the real group key is independent of the rest of the experiment. In other words, unless $\Adv$ inputs $\epochSecret$ to the RO, the real group key outputted in hybrid 2 is distributed identically as the random key in hybrid~3.

\newcommand{\secsHash}{\variable{\small SecsHashed}}
\newcommand{\breaksRcca}{\variable{\small BreaksRCCA}}
\newcommand{\initHash}{\variable{\small InitHashed}}
\newcommand{\commitHash}{\variable{\small CommHashed}}
\newcommand{\joinerHash}{\variable{\small JoinHashed}}

Therefore, $\Adv$'s distinguishing advantage is upper-bounded by the probability that the following event $\variable{SecsHashed}_\hgnodeid$ occurs for at least one epoch $\hgnodeid$. For convenience, the event is more general and also considers init and joiner secrets.
\begin{description}
  \item[] {\bf Event $\secsHash_\hgnodeid$ : } At the end of the experiment, $\hgnodeid$ is confidential and $\hgnodeid$'s init, epoch or joiner secret is contained in a value inputted by $\Adv$ to RO.
\end{description}
Formally, it is left to prove the following lemma.
\begin{lemma}
  There exists a reduction $\Bdv$ such that
  \begin{multline*}
    \Pr[\exists \hgnodeid : \secsHash_\hgnodeid] \leq 4q_e^2q_h/2^\kappa \\ + q_e^2\log(q_n)\cdot\textnormal{Adv}^\mmindrcca_{\mmPKE,q_e\log(q_n),q_n}(\Bdv).
  \end{multline*}
\label{thm:hybrid2-1}\end{lemma}

\headingB{Bounding probability of bad events.}
An epoch $\hgnodeid$ is confidential if $\safeGrpSecsSecure(\hgnodeid)$ is true (all predicates are defined in \cref{fig:safe}). The latter predicate is recursive, starting at the root epoch with $\hgnodeid=0$. Accordingly, we will prove a recursive upper bound on the probability of $\secsHash_\hgnodeid$. Formally, \cref{thm:hybrid2-1} is implied by the following lemma.
\begin{lemma}
  There exists a reduction $\Bdv$ and (arbitrary) events $\breaksRcca_\hgnodeid$\footnote{The
    lemma implies \cref{thm:hybrid2-1} no matter what $\breaksRcca_\hgnodeid$ is. The name will become clear later in the proof.}
  for $\hgnodeid\in\N$ such that
  \begin{enumerate}[label=\alph*)]
    \item
    $\Pr[\exists \hgnodeid : \secsHash_0] \leq 4q_h/2^\kappa.$
    \item For each $\hgnodeid > 0$ with parent $\hgnodeid_p$, we have
    \\$\Pr[\secsHash_{\hgnodeid}] \leq \ 4q_h/2^\kappa + \Pr[\secsHash_{\hgnodeid_p}] $\\\strut\hfill$+\  \Pr[\breaksRcca_{\hgnodeid}].$
    \item
    $\Pr[\exists \hgnodeid : \breaksRcca_\hgnodeid] \\\strut\hfill\leq\ q_e\log(q_n)\cdot\textnormal{Adv}^\mmindrcca_{\mmPKE,q_e\log(q_n),q_n}(\Bdv).$
  \end{enumerate}
%  \begin{equation}\begin{split}
%    \Pr[\exists \hgnodeid : \variable{SecsBad}_0] \leq 2q_h/2^\kappa.
%  \end{split}\end{equation}
%  \begin{equation*}
%    \Pr(\variable{SecsHashed}_{\hgnodeid>0})) \leq 3q_h/2^\kappa + \Pr(\variable{SecsHashed}_{\hgnodeid_p}) + \Pr(\variable{BreaksRCCA}_{\hgnodeid}) .
%  \end{equation*}
\label{thm:hybrid2-2}\end{lemma}
To see that \cref{thm:hybrid2-2} implies \cref{thm:hybrid2-1}, observe that \cref{thm:hybrid2-2} implies
\begin{align*}
\Pr[&\secsHash_\hgnodeid]\\& \leq \sum_{i=0}^{\hgnodeid-1}(4q_h/2^\kappa + \Pr[\breaksRcca_i]) \\&\leq 4q_eq_h/2^\kappa + \Pr[\exists \hgnodeid : \breaksRcca_\hgnodeid] \\&\leq 4q_eq_h/2^\kappa + q_e\log(q_n)\cdot\textnormal{Adv}^\mmindrcca_{\mmPKE,q_e\log(q_n),q_n}(\Bdv),
\end{align*}
where the first step follows from a) and b) in  \cref{thm:hybrid2-2}.
We arrive at  \cref{thm:hybrid2-1}, since 
 by union bound $\Pr[\exists \hgnodeid : \secsHash_\hgnodeid] \leq q_e \cdot \max_{\hgnodeid} \Pr[\secsHash_\hgnodeid]$.


\headingB{Proof of \cref{thm:hybrid2-2} a).}
The root epoch does not have joiner and epoch secrets. The init secret of epoch $0$ is chosen at random by the group creator $\pgod$. Moreover, it is independent of the rest of the experiment apart from being stored by $\pgod$ in epoch $0$. The reason is that any other values are derived by first hashing it, and outputs of the RO are independent of the inputs.
If epoch $0$ is confidential, then $\pgod$ is not corrupted in epoch $0$, so $\Adv$ has no information about the init secret. Therefore, the best strategy for $\Adv$ to trigger $\secsHash_0$ is by guessing the init secret, which succeeds with probability at most $q_h/2^\kappa < 4q_h/2^\kappa$.

\headingB{Proof of \cref{thm:hybrid2-2} b).}
Take any non-root epoch $\hgnodeid>0$ with parent $\hgnodeid_p$. Let $\initSecret$, $\epochSecret$, $\joinerSecret$ and $\commitSecret$ denote $\hgnodeid$'s init, epoch, joiner and commit secrets. Let $\initSecret_p$ denote $\hgnodeid_p$'s init secret.

Observe that the only dependencies between $\initSecret$, $\epochSecret$, $\joinerSecret$ and the rest of the experiment are as follows: 1) $\initSecret$ is stored by parties in $\hgnodeid$, 2) $\joinerSecret$ is the output of the RO on input $\commitSecret$ together with $\initSecret_p$, 3) $\joinerSecret$ is encrypted to new members. (Note that any other values are derived by first hashing it, and outputs of the RO are independent of the inputs.)

Assume for a moment that $\hgnodeid$ is confidential. Then, no party in $\hgnodeid$ is corrupted, so dependency 1) does not exist. Recall that confidentiality requires either $\safeGrpSecsSecure(\hgnodeid_p)$ is true or $\safeRestoresGrpSec(\hgnodeid)$ is true. Observe that dependency 2) does not exist either unless one of the following events occurs:
\begin{description}
  \item[] {\bf Event $\initHash_{\hgnodeid_p}$ : } At the end of the experiment, the value of the predicate $\safeGrpSecsSecure(\hgnodeid_p)$ is true and $\initSecret_p$ (of $\hgnodeid_p$) is contained in some value inputted by $\Adv$ to the RO.
  \item[] {\bf Event $\commitHash_{\hgnodeid}$ : } At the end of the experiment, the predicate $\safeRestoresGrpSec($ $\hgnodeid)$ is true and $\commitSecret$ (of $\hgnodeid$) is contained in some value inputted by $\Adv$ to RO.
\end{description}

This means that unless $\initHash_{\hgnodeid_p}$ or $\commitHash_{\hgnodeid}$ occurs, $\Adv$ has no information about $\initSecret$ and $\epochSecret$. Therefore, the best strategy for $\Adv$ to trigger $\secsHash_\hgnodeid$ is to either guess $\initSecret$ or $\epochSecret$ at random, or trigger one of the above events, or input the joiner secret based only on dependency 3). We capture the last event by
\begin{description}
  \item[] {\bf Event $\joinerSecret_{\hgnodeid}$ : } At the end of the experiment, none of the values inputted by $\Adv$ to the RO includes $\initSecret_p$ (of $\hgnodeid_p$) and $\commitSecret$ (of $\hgnodeid$) together, but some value contains $\joinerSecret$ (of $\hgnodeid$).
\end{description}

Therefore, we have
\begin{multline*}
  \Pr\left[\secsHash_\hgnodeid\right] \leq 2q_h/2^\kappa + \Pr[\initHash_{\hgnodeid_p}] \\ + \Pr\left[\commitHash_{\hgnodeid}\right].
\end{multline*}
By definition, $\Pr[\initHash_{\hgnodeid_p}] \leq \Pr[\secsHash_{\hgnodeid_p}]$. Moreover, we define
\begin{description}
  \item[] {\bf Event $\breaksRcca_\hgnodeid$ : } Either $\commitHash_{\hgnodeid}$ or $\joinerHash_{\hgnodeid}$ occurs.\footnote{Intuitively,
    the only dependency between the commit and joiner secrets comes from encryptions, so inputting the secrets to the RO requires breaking \indrcca.}
\end{description}
This proves the claim.

\headingB{Proof of \cref{thm:hybrid2-2} c).}
We construct two reductions $\Bdv[1]$ and $\Bdv[2]$ whose advantages bound the probability of the event $\exists \hgnodeid : \joinerHash_{\hgnodeid}$ and of $\exists \hgnodeid : \commitHash_{\hgnodeid}$, respectively.

\begin{lemma}
  There exists a reduction $\Bdv[1]$ such that
  \begin{equation*}
    \Pr(\exists \hgnodeid : \joinerHash_{\hgnodeid}) \leq q_e\cdot\textnormal{Adv}^\mmindrcca_{\mmPKE,1,q_n}(\Bdv[1]).
  \end{equation*}
\end{lemma}
\begin{proof}
  Take any epoch $\hgnodeid$ with parent $\hgnodeid_p$ (the root does not have a joiner secret). Observe that the joiner secret of $\hgnodeid$ is never stored in the state of \saik. Moreover, the only message that may include it is the message creating $\hgnodeid$ which potentially encrypts it to a new member. This means that if $\Adv$ does not input to the RO the init secret of $\hgnodeid_p$ together with the commit secret of $\hgnodeid$, then the only part of its view that may depend on the joiner of $\hgnodeid$ is the ciphertext in the message creating $\hgnodeid$. In particular, if $\hgnodeid$ is honestly created and adds a party $\id_r$, then the ciphertext encrypts the joiner under $\id_r$'s key from the AKS (i.e., our PKI). Since the AKS is uncorruptible and $\id_r$ deletes the secret key immediately after using it, this means that inputting the joiner to the RO implies breaking security of \mmPKE.

  More formally, consider the following reduction $\Bdv[1]$ playing the \mmowrcca game with 1 user. $\Bdv[1]$ guesses an epoch $\hgnodeid^* \in [q_e]$ and runs $\Adv$, emulating the CGKA functionality and the simulator as in hybrid 2. If $\hgnodeid^*$ is injected or not created on an add, $\Bdv[1]$'s emulation is identical to hybrid 2. Otherwise, $\Bdv[1]$'s emulation will be identical to hybrid 2 but where the joiner secret $\joinerSecret^*$ of $\hgnodeid^*$ is replaced the \mmowrcca challenge message $m^*$. $\Bdv[1]$ will use a special symbos \literal{test} to denote this unknown value of $m^*$ in the emulation.

  In particular, when an $\id_s$ creates $\hgnodeid^*$ while adding an $\id_r$, $\Bdv[1]$ embeds the single public key $\mmpkepk^*$ from its game as the key generated for $\id_r$ by the AKS (recall that the AKS generates the key pair $(\mmpkepk^*,\mmpkesk^*)$ at the moment $\id_s$ requests it to create the epoch). Further, $\Bdv[1]$ computes \saik's state for $\hgnodeid^*$ according to the protocol. It then replaces the (fresh) joiner secret generated by \saik by \literal{test} in all places, including the programmed RO inputs and outputs. Finally, $\Bdv[1]$ sends to the challenger the message vector $\vec m$ encrypted by $\id_s$ and the last index in this vector, denoting the (only) position of the joiner secret. The challenger sends back a ciphertext $C^*$, which $\Bdv[1]$ uses in the message sent by $\id_s$.

  If $\id_r$ uses $\mmpkesk^*$, $\Bdv[1]$ uses the Dec oracle. Note that Dec may output \literal{test}, which is used consistently with the symbol for the unknown joiner $m^*$. If $\Adv$ inputs to tje RO the init secret $\initSecret^*$ of $\hgnodeid^*$'s parent together with the commit $\commitSecret^*$ of $\hgnodeid^*$, $\Bdv[1]$ halts and gives up. At the end of the experiment, $\Bdv[1]$ searches all $\Adv$'s queries to the RO for an $m^*$ that allows it to win.

  We first claim that, until $\Bdv[1]$ gives up or the experiment ends, its emulation is perfect. In particular, since $\Adv$ does not input $\initSecret^*$ with $\commitSecret^*$ to the RO, which means that, apart from $C^*$, its experiment is independent of $\joinerSecret^*$. This means that $\Bdv[1]$ simulates it perfectly by using \literal{test} instead of $\joinerSecret^*$.
  Second, we claim that if $\joinerHash_{\hgnodeid^*}$ occurs, then $\Bdv[1]$ wins. Indeed, the event guarantees that $\Adv$ inputs $m^*$ to the RO and $\Bdv[1]$ does not give up
   $\Adv$ does not input $\initSecret^*$ with $\commitSecret^*$ to the RO.

  Therefore, we have
  \begin{align*}\textnormal{Adv}^\mmindrcca_{\mmPKE,1,q_n}(&\Bdv[1]) \\ \geq& \Pr(\joinerHash_{\hgnodeid^*}) \\ \geq& 1/q_e\Pr(\exists \hgnodeid : \joinerHash_{\hgnodeid}).
  \end{align*}
\end{proof}

\begin{lemma}
  There exists a reduction $\Bdv[2]$ such that
  \begin{align*}
    \Pr(\exists \hgnodeid : &\commitHash_{\hgnodeid}) \\ \leq\ & q_e\cdot\textnormal{Adv}^\mmindrcca_{\mmPKE,q_e\log(q_n),q_n}(\Bdv[2]).
  \end{align*}
\end{lemma}
\begin{proof}
We start by describing the reduction $\Bdv$. Recall that \saik generates \mmPKE key pairs and ciphertexts when epochs are created: When a party $\id_s$ creates an epoch, it generates a hash chain of secrets, consisting of $\log(q_n)$ path secrets and the commit secret. Each path secret is then hashed to obtain randomness used to generate a single key pair. Moreover, if a new member is added, its new \mmPKE key pair is generated by the AKS. Then, $\id_s$ sends out all new public keys and a single ciphertext encrypting secrets to different recipients.

The reduction $\Bdv$ runs $\Adv$, emulating the functionality and the simulator executing \saik as in hybrid 2 with the following differences. First $\Bdv$ embeds public keys from the \mmowrcca game as public keys sent when epochs are created. It generates all secrets itself independently of the key pairs. Further, it picks a random epoch $\hgnodeid^*$ and a random index $i^* \in [\log(q_n)]$. When $\hgnodeid^*$ is created, $\Bdv$ asks the challenger for an encryption $C^*$ of the secrets $\Bdv$ generated, but with the $i^*$-th secret replaced by the challenge message $s^*$ $\Bdv$ is supposed to compute. $C^*$ is then embedded in the sent message. For the the unknown value of the $i^*$-th secret, $\Bdv[\hgnodeid]$ uses a special symbol \literal{test} (it is used for bookkeeping, e.g. to consistently program the RO).\footnote{One
  may expect that if $\commitHash_\hgnodeid$ occurs, then the challenge can be embedded in the commit secret inputted by $\Adv$ to the RO. Intuitively, this cannot work, because confidentiality of the commit secret clearly relies on the confidentiality of path secrets before it and of path secrets from which encryption keys were derived.
}

When a party is corrupted, $\Bdv$ corrupts all receivers whose secret keys are in the party's state. When $\Adv$ sends a new value to the RO, $\Bdv$ checks if it contains its solution $s^*$ and, if so, sends it to the challenger and halts. Otherwise, $\Bdv$ programs the RO consistently with already generated values. Importantly, if the output is key-generation randomness for an \mmowrcca receiver, $\Bdv$ corrupts this receiver to obtain it. (Here we use programmability to deal with adaptive corruptions.)

When a party $\id_r$ receives a message, $\Bdv$ runs $\id_r$'s protocol with the help of the Dec oracle. Note that Dec may output \literal{test}, which $\Bdv$ uses for the unknown value of the $i^*$-th secret.

% ==================================================== %
\heading{Precise description of $\Bdv$.}
At the beginning, $\Bdv$ guesses an epoch $\hgnodeid^*\in[q_e]$ and an index $i^* \in [\log(a_n)]$. Then, it runs $\Adv$, emulating for it the functionality and the simulator by running their code with the following differences.

Recall that the simulator stores a single ratchet tree per epoch. $\Bdv$ modifies these trees by assigning to each node two additional labels: one storing a receiver in the \mmowrcca game and one storing a secret. The root's secret stores the epoch's commit secret. The secret of any other internal node stores the path secret from which its key pair was derived. The leaf's secrets are not used. Alternatively, a secret can be set to $\bot$ in case of injections or \literal{test} to denote the unknown \mmowrcca challenge $s^*$. A joiner secret can also take value \literal{test}. Secret keys in the ratchet tree will not be used.

To emulate the RO, $\Bdv$ keeps a table of programmed input-output pairs. Some inputs and outputs may contain a special symbol \literal{test}. The symbol is not in the RO input domain, so it cannot be inputted by $\Adv$ (but it will be used by $\Bdv$ when the protocol evaluates hashes). Whenever $\Adv$ sends a new input, $\Bdv$ first checks if it contains its solution and halts if this is the case. Else, it checks if the output should be equal to key-generation randomness derived from a path secret in some ratchet tree node. If so, $\Bdv$ corrupts the node's receiver to obtain the RO output. Else, it programs a fresh value.

Further, $\Bdv$ makes the following changes to how the functionality and simulator process different inputs of $\Adv$.
\begin{itemize}
  \item {\sc $\id_s$ sends.} $\Bdv$ generates the new epoch and the message handed to $\Adv$ as follows:
    \begin{enumerate}
      \item Generate the new epoch's path secrets, as well as all secrets in the key schedule at random. If the created epoch is $\hgnodeid^*$, replace the $i^*$-th secret (a path, commit or joiner secret) by \literal{test}. Program the RO according to how the secrets are derived.
      \item Generate the new epoch's ratchet tree: Copy the ratchet tree from $\id_s$'s epoch, apply the action and (re-)assign node labels as follows: For each node on $\id_s$'s path and, in case of an add, the node of the new member, set the \mmowrcca receiver to the next receiver not appearing in any ratchet tree, and set the public key to the public key of its receivers. The path secret of $\id_s$ leaf is $\bot$ (since its key pair is generated using fresh randomness) and the path secret of each node above it is set to the secret chosen in Step 1.
      \item Generate the ciphertext included in the sent packet: If the created epoch is not $\hgnodeid^*$, then simply encrypt the secrets. Else, compute the public key vector $\vec \mmpkepk$ and message vector $\vec m$ with the secrets as in the protocol. Let $S$ be the set of all $i$ such that $\vec m[i]=\literal{test}$. $\Bdv$ sends $\vec\mmpkepk$, $\vec m$ and $S$ to the challenger to obtain the sent ciphertext.
      \item Use the above values to complete emulating the functionality and the simulator as in their code.
    \end{enumerate}
  \item {\sc $\id_r$ receives a message removing it.}
    If the message removes $\id_r$, then it carries no secrets, so $\Bdv$ simply runs $\id_r$'s protocol.
  \item {\sc A current member $\id_r$ receives a message not removing it.}
    $\Bdv$ first decrypts the path secret $s$ from the packet. Say $\id_r$ uses the keys in a ratchet-tree node $v$ to decrypt. If $v$ has an \mmowrcca receiver assigned, $\Bdv$ sets $s$ to the output of the decryption oracle. Else, if $v$ has no receiver but it has a path secret, $\Bdv$ derives $v$'s key pair by hashing the secret, programming the RO if necessary, and decrypts $s$. Else, it rejects the packet on behalf of the simulator.

    After decrypting, $\Bdv$ checks if $s$ is the solution $s^*$ and halts if this is the case. If not, it proceeds as follows.

    $\Bdv$ computes the epoch secret $\epochSecret$ that identifies the epoch into which $\id_r$ transitions. The value of $\epochSecret$ is derived from $s$ the same way as in the protocol, where hashes are evaluated using the RO table and the RO is programmed to a fresh value if necessary. Note that some evaluations may involve the symbol \literal{test}.

    If $\id$ transitions to an injected epoch, $\Bdv$ creates or updates the epoch as follows:
    \begin{enumerate}
      \item If the epoch does not exist, create its ratchet tree by applying the action specified in the packet to the ratchet tree from $\id$'s current epoch and set public keys, secrets and \\\mmowrcca receivers of all nodes on the re-keyed path to $\bot$. Set the init, epoch and joiner secrets to those derived from $\epochSecret$.
      \item Let $u$ be the least common ancestor of the sender's and $\id$'s leaves in the ratchet tree. Use the decrypted secret $s$ to derive and assign the path secrets and public keys for $u$ and each node above it by evaluating the RO, programming if necessary. (In case the tree already existed, this potentially adds missing secrets to it.)
      \item Assign to each node below $u$ the public key from the packet.
    \end{enumerate}

    Finally, $\Bdv$ verifies if $\id_r$ accepts the packet, as in the simulator. If it does, then $\Bdv$ transitions $\id_r$. Else, it undoes all changes.
  \item {\sc A new member $\id_r$ receives a message.}
    In this case $\id_r$ receives two ciphertexts, one with its path secret and one with the joiner secret. $\Bdv$ decrypts these secrets as in case a current member receives a message. If one of them is the solution $s^*$, $\Bdv$ sends it to the challenger and halts.

    Then, $\Bdv$ computes the epoch secret of the epoch into which $\id_r$ transitions by hashing the decrypted joiner secret. If this epoch is injected, $\Bdv$ creates or updates it the same way as when current member receives. Note that if the epoch does not exist, $\Bdv$ uses the public part of the ratchet tree from $\id_r$'s packet.

  \item {\sc Expose.}
    When $\id$ is exposed, $\Bdv$ computes its \mmPKE secret keys by hashing the path secrets from the ratchet tree in $\id$'s current epoch. $\Bdv$ corrupts the \mmowrcca receivers if necessary.
\end{itemize}

% ==================================================== %
\headingB{The reduction wins.}
Assume $\commitHash_{\hgnodeid}$ occurs. We show that there exist $\hgnodeid^*$ and $i^*$ such that $\Bdv$ wins. We start with a simple observation.
\begin{lemma}
  If $\safeRestoresGrpSec(\hgnodeid)$ is true, then for each $v$ in $\tree$, $v.\mmpkepk$ is generated during an honest send.
\label{lem:confproof-1}\end{lemma}
\begin{proof}
  Take any $v$ in $\tree$. Let $\hgnodeid_0$ be the epoch which introduces $v.\mmpkepk$ and let $\id_s$ be its (alleged) creator. Assume towards a contradiction that $\hgnodeid_0$ is injected. If $\hgnodeid_0=\hgnodeid$, then we immediately get a contradiction with $\commitHash_\hgnodeid$. Else, this means that $\safeKnowsSecrets(\hgnodeid_0, \id_s)$ is true. Moreover, no epoch between $\hgnodeid_0$ and $\hgnodeid$, including $\hgnodeid$, is created by $\id_s$ or removes it, since this would replace $v$'s keys. Therefore, $\safeIndSecsSecure(\hgnodeid, \id_s)$ is false and $\safeRestoresGrpSec(\hgnodeid)$ is false, which contradicts with $\commitHash_\hgnodeid$ being true.
\end{proof}

Let $\tree$ be the ratchet tree in $\hgnodeid$. By \cref{lem:confproof-1}, we can assign to each internal node $v$ in $\tree$ a secret: each non-root node is assigned the path secret $s$ encrypted by $\Bdv$ when $v$'s public key was introduced and the root is assigned the commit secret of $\hgnodeid$.
$\commitHash_{\hgnodeid}$ guarantees that $\Adv$ inputs to the RO the secret of at least one node, namely the root. Let $v^*$ be a node in $\tree$ with the maximal distance from the root whose secret $s^*$ is inputted by $\Adv$ to the RO. Let $\hgnodeid^*$ be the epoch before $\hgnodeid$ which creates $v^*$'s secret $s^*$. We claim that $\Bdv$ wins with the guess $\hgnodeid^*$ and $i^*$ set to $v^*$'s index.

Indeed, $\hgnodeid^*$ is honestly created (by \cref{lem:confproof-1}), so $\Bdv$ can embed the challenge. It is left to show that each public key used to encrypt $s^*$ belongs to an uncorrupted \mmowrcca receiver. For this, observe that each such key belongs to a node $v$ in $v^*$'s sub-tree in the ratchet tree $\tree^*$ of $\hgnodeid^*$. Moreover, $v$'s key does not change between $\hgnodeid^*$ and $\hgnodeid$, since this would replace $v^*$'s keys as well. By \cref{lem:confproof-1}, this means that $v$'s key belongs to some \mmowrcca receiver.

It remains to show that this receiver is not corrupted. This can happen in two cases: 1) if $\Adv$ inputs to the RO the path secret from which $v$'s key pair was derived or 2) $\Adv$ corrupts a party holding $v$'s secret key. Case 1) cannot occur for the following reason: $v$'s key pair can only be derived from the secret of an internal node $u$ below $v$ in $\tree^*$. Note that $u$ is also below $v^*$ in $\tree^*$. Therefore, $u$'s secret (and keys) do not change between $\hgnodeid^*$ and $\hgnodeid$, since this would replace $v^*$'s keys as well. Since $v^*$ has the maximal distance among nodes with secrets inputted to the RO, $\Adv$ does not input $u$'s secret.
Finally, we show that case 2) cannot occur as well.
\begin{lemma}
  If $\safeRestoresGrpSec(\hgnodeid)$ is true, then for each $v$ in $\tree$, no party holding $v.\mmpkesk$ is corrupted.
\end{lemma}
\begin{proof}
  Take any $v$ in $\tree$. Let $\hgnodeid_0$ be the epoch which introduces $v.\mmpkepk$ and let $\hgnodeid[1], \dots, \hgnodeid_\ell$ be the epochs after $\hgnodeid_0$ that can be reached from it without $v$'s keys being replaced. Note that these epochs form a tree rooted at $\hgnodeid_0$.

  We first observe that $v$'s subtree is the same in the ratchet trees of all epochs $\hgnodeid_0, \dots, \hgnodeid_\ell$, because any modification replaces $v$'s keys. Moreover, $\hgnodeid$ is one of these epochs, so this subtree is the same as in $\tree$. Let $\id[1], \dots, \id_n$ be the parties in $v$'s subtree in $\tree$.

  Second, we observe that if $\safeRestoresGrpSec(\hgnodeid)$ is true, then no $\id_i$ is corrupted in any epoch $\hgnodeid_j$. The reason is that for any $\id_i$, each $\hgnodeid_j$ is connected to $\hgnodeid$, and $\hgnodeid$ is one of $\hgnodeid_0, \dots, \hgnodeid_\ell$, by a sequence of epochs not created by $\id_i$ and not removing or adding it. This is because any such operation would replace $v$'s keys. Therefore, if $\id_i$ was corrupted in some $\hgnodeid_j$, then the predicate $\safeIndSecsSecure(\hgnodeid, \id_i)$ would be false and the predicate $\safeRestoresGrpSec(\hgnodeid)$ would be false, which contradicts $\variable{CommitHashed}_\hgnodeid$.

  Finally, it is left to show that $v.\mmpkesk$ is held only by $\id[1], \dots, \id_n$ in epochs $\hgnodeid_0, \dots, \hgnodeid_\ell$. It is easy to see that this is implied by the following statement:
  \begin{description}
    \item[] {\it Statement : } Assume an $\id^\bot$ in an epoch $\hgnodeid^\bot$ stores a secret key for a ratchet tree node $v^\bot$ such that $v^\bot.\mmpkesk=v.\mmpkepk$ for some $v$ in $\tree$. Then, there is party $\id_i$ and a path between $\hgnodeid$ and $\hgnodeid^\bot$ that does not \emph{heal} $\id_i$, i.e., no epoch on the path is created by $\id_i$, removes it or adds it.
  \end{description}
  We next prove the above statement by induction on the height of $v^\bot$.
  For the base case where $v^\bot$ is a leaf, observe that $v^\bot$'s keys are not generated from a seed and that $v^\bot.\mmpkesk$ is only stored by $v^\bot$'s owner after it generates it while creating an epoch. So, $v^\bot.\mmpkesk=v.\mmpkesk$ can only happen if $v^\bot.\mmpkesk$ is generated by an $\id_i$ when it creates an epoch $\hgnodeid_0$ before $\hgnodeid$. Therefore, $\hgnodeid_0$ is a common ancestor of $\hgnodeid^\bot$ and $\hgnodeid$ and can be reached from both epochs by a path that does not heal $\id_i$.

  Now assume $v^\bot$ is an internal node and the statement holds for any node with smaller height. Let $\hgnodeid_0^\bot$ be the epoch before $\hgnodeid^\bot$ that introduces $v^\bot.\mmpkesk$ into the state of $\id^\bot$. Further, let $\hgnodeid_0$ be the epoch that introduces $v.\mmpkesk$ into $\tree$.

  We have two cases: First, if $\hgnodeid^\bot_0$ is not injected, then we must have $\hgnodeid^\bot_0=\hgnodeid_0$. The reason is that the only non-injected epoch introducing $v.\mmpkepk$ is $\hgnodeid_0$. Moreover, all parties transitioning to $\hgnodeid^\bot_0=\hgnodeid_0$ agree on the public ratchet tree, so $v^\bot=v$ and the subtree of $v^\bot=v$ is the same in $\hgnodeid$ and $\hgnodeid^\bot$. Therefore, the statement is obvious in this case.

  Second, assume $\hgnodeid^\bot_0$ is injected. Let $u^\bot$ be the node in the ratchet tree of $\hgnodeid_0^\bot$ used by $\id^\bot$ to decrypt $v^\bot$'s path secret $s$. For this proof sketch, we assume that there exists a node $u$ such that $u.\mmpkepk$ corresponds to $u^\bot.\mmpkesk$ and $u.\mmpkepk$ was used to encrypt $s$ when $\hgnodeid_0$ was created.\footnote{This
    is only false if $\Adv$ manages to re-encrypt a securely encrypted $s$ under a different key. Being able to do so implies breaking security of \mmPKE. Formally, the reduction $\Bdv[\hgnodeid]$ in the full proof searches for the solution $s^*$ in both $\Adv$'s RO queries and injected messages that it decrypts using the Dec oracle or some other known keys. Accordingly, $v^*$ is taken to be the lowest whose secret is not inputted to the RO or re-encrypted and injected.}
  This means that $u$ is in the subtree of $v$ in $\hgnodeid_0$ and, since this tree is the same as in $\tree$, also in the subtree of $v$ in $\hgnodeid$. Further, $u^\bot$ is in the subtree of $v^\bot$ in $\hgnodeid_0^\bot$ and, since this tree is the same as in $v^\bot$'s subtree in $\hgnodeid^\bot$, also in the subtree of $v^\bot$ in $\hgnodeid^\bot$. Moreover, $u^\bot$ is strictly below $v^\bot$ and $u^\bot.\mmpkesk=u.\mmpkesk$, so by induction hypothesis, there is an$\id_i$ and a path between $\hgnodeid$ and $\hgnodeid^\bot$ that does not \emph{heal} $\id_i$.
\end{proof}
\end{proof}

\newcommand{\forges}{\variable{\small Forges}}
\newcommand{\forgesa}{\variable{\small ForgesAsym}}
\newcommand{\forgess}{\variable{\small ForgesSym}}
\subsection{\saik Guarantees Authenticity}\label{sec:protsec5}
The fourth and final Hybrid introduces authenticity, which is formalized by restoring the \KwAuth{} predicate. It is the ideal experiment with $\funcCGKA$.
\begin{description}
\item[] {\bf Hybrid 4: $\ucideal_{\funcCGKA^4, \ucsim^4}$.} The functionality $\funcCGKA^4$ uses the original \KwAuth{} predicate from $\funcCGKA$. The simulator $\ucsim^4$ is the same as $\ucsim^4$.
\end{description}

In the remainder of this section, we show that if $\sigscheme$ and $\mac$ are unforgeable and if $\mmPKE$ is \mmowrcca secure, then \saik guarantees authenticity, that is, hybrids 3 and 4 are indistinguishable. We note that security of \mmPKE is needed e.g. to guarantee secrecy of \mac keys.

\headingB{Game-based perspective.}
We observe that hybrids 3 and 4 are identical unless a bad event $\forges$ occurs. Roughly, $\forges$ happens if $\Adv$ breaks authenticity, that is, if it successfully impersonates an $\id_s$ towards $\id_r$ in an epoch $\hgnodeid$ such that \KwAuth{} is true for $\id_s$ in $\hgnodeid$. Therefore, $\Adv$'s advantage in distinguishing the hybrids is upper bounded by the probability of $\forges$. This means that distinguishing hybrids 3 and 4 can be seen as a typical authenticity game, where the adversary wins by forging messages accepted by the protocol, as expressed by $\forges$.

\headingB{Bad events.}
Let $\Adv$ be any environment. The hybrids are identical unless the following event $\forges$ occurs: There exists an epoch $\hgnodeid$ with two members $\id_s$ and $\id_r$ s.t. the following condition holds:
\begin{description}
  \item[] {\bf Condition $\forges(\hgnodeid, \id_s, \id_r)$: } $\KwAuth{}(\hgnodeid, \id_s)$ is true and $\Adv$ makes $\id_r$ accept a message that either (A) makes $\id_r$ transition to a new epoch $\hgnodeid'$ with $\hg[\hgnodeid'].\hginj$ true ($\hgnodeid'$ is injected) and $\hg[\hgnodeid].\hgorig=\id_s$ or (B) removes $\id_r$ and $\id_s$ did not remove $\id_r$.
\end{description}
Note that (A) implies that asserting \authPreserved in $\funcCGKA$ fails, and (B) implies that the assertion on input Receive that removes the receiver fails. These are the only places where $\funcCGKA$ uses \KwAuth{}.

Since epochs in detached trees are not authentic, in the remainder of the proof we only consider epochs in the main history-graph tree. For such an epoch $\hgnodeid$, $\KwAuth{}(\hgnodeid, \id_s)$ is true if either the group secrets in $\hgnodeid$ or the individual secrets of $\id_s$ are secure. Accordingly, we define two sub-events of $\forges$ depending on which secrets are secure:
\begin{description}
  \item[] {\bf Event $\forgess$: } There exists an epoch $\hgnodeid$ with two members $\id_s$ and $\id_r$ such that $\safeGrpSecsSecure(\hgnodeid)$ and $\forges(\hgnodeid, \id_s, \id_r)$ are true.
  \item[] {\bf Event $\forgesa$: } There exists an epoch $\hgnodeid$ with two members $\id_s$ and $\id_r$ such that $\safeIndSecsSecure(\hgnodeid, \id_s)$ and $\forges(\hgnodeid, \id_s, \id_r)$ are true.
\end{description}
It remains to bound the probability of each $\forgesa$ and $\forgess$.

\headingB{Asymmetric forgery.}
We next prove the following lemma
\begin{lemma}
There exists a reduction $\Bdv[1]$ such that
\begin{equation*}
    \Pr[\forgesa] \leq 2q_e\cdot \textnormal{Adv}^{\ufcma}_\sigscheme(\Bdv[1]).
\end{equation*}
\end{lemma}
$\Bdv[1]$ emulates hybrid 3 for $\Adv$ and embeds the challenge key $\ersvk^*$ as one of the verification keys honestly generated during the execution. Keys are honestly generated when group members create epochs during send: each send introduces one new key pair for the sender and, in case of an add, one for the added member (in this case, it is generated by the AKS at the moment of send). Therefore, there are at most $2q_e$ key pairs.
$\Bdv[1]$ chooses the index of the key to replace by $\ersvk^*$ at random. It uses the Sign oracle to sign honestly sent messages that verify with $\ersvk^*$. If a party holding the corresponding $\ssk^*$ is corrupted, it gives up.

We first show that if $\forgesa$ occurs, then the receiver $\id_r$ (see the definition of $\forgesa$) verifies the injected message with an honestly generated key $\ersvk_r$. This means that $\Bdv[1]$ has a chance of embedding $\ersvk^*$ as $\ersvk_r$.
%with probability $\Pr[\forgesa]/(2q_e)$, both $\forgesa$ occurs and the receiver $\id_r$ (see the definition of $\forgesa$) uses the verification key $\ersvk_r=\ersvk^*$. This is non-trivial, because the reduction can embed $\ersvk^*$ only in an honestly generated key, so we have to show that $\ersvk_r$ is honestly generated.
\begin{claim}
  If $\forgesa$ occurs then the key $\ersvk_r$ used by $\id_r$ to verify the injected message is honestly generated.
\end{claim}
\begin{proof}
  Assume $\forgesa$ occurs.
  Notice that $\ersvk_r$ is introduced into $\id_r$'s state when it accepts a message from $\id_s$ that transitions it into an ancestor $\hgnodeid_0$ of $\hgnodeid_s$.
  Observe first that $\hgnodeid_0$ is not injected. The reason is that no epoch between $\hgnodeid_0$ and $\hgnodeid_s$ is created by $\id_s$ or removes it, since this would remove $\ersvk_r$ from $\id_r$'s state. So, if $\hgnodeid_0$ was injected, $\safeKnowsSecrets(\hgnodeid_0, \id_s)$ would be true and $\safeIndSecsSecure(\hgnodeid_s, \id_s)$ would be false, which contradicts $\forgesa$.

  This means that $\id_s$ created $\hgnodeid_0$ during a send operation and at that point generated an honest verification key $\ersvk_s$ for itself. We know (from the proof that \saik guarantees consistency) that parties in the same epoch agree on the ratchet tree, which contains all verification keys. Therefore, $\ersvk_r=\ersvk_s$, so $\ersvk_r$ is honestly generated.
\end{proof}

We next show that no party holding the secret key $\erssk_r$ corresponding to $\ersvk_r$ used by $\id_r$ is corrupted. This means that if $\forgesa$ occurs and $\Bdv[1]$ guesses correctly and embeds $\ersvk^*$ as $\ersvk_r$, then $\Bdv[1]$ does not give up when $\erssk^*$ is corrupted.
\begin{claim}
  If $\forgesa$ occurs then no party holding $\erssk_r$ corresponding to $\ersvk_r$ used by $\id_r$ to verify the injected message is corrupted.
\end{claim}
\begin{proof}
  Assume towards a contradiction that \forgesa occurs and a party holding $\erssk_r$ is corrupted in some epoch $\hgnodeid^\bot$. Let $\hgnodeid_0^\bot$ be the epoch before $\hgnodeid^\bot$ which introduces $\erssk_r$ into its state.

  Observe that (honest) parties only store the signing keys that they generate themselves while creating epochs or that the AKS generates for them when they are added. Moreover, such honestly generated keys are not re-computed and the AKS generates a fresh key pair each time a party is added.
  This means that the corrupted party is $\id_s$. Moreover, if $\hgnodeid_0^\bot$ is not injected, then it is the epoch $\hgnodeid_0$ which introduces $\ersvk_r$ into the state of $\id_r$. On the other hand if $\hgnodeid_0^\bot$ is injected, then it must add $\id_s$ (and not be created by it).

  Observe further that $\hgnodeid_0^\bot$ and $\hgnodeid^\bot$ are connected by a path of epochs not created by $\id_s$ and not removing it, as this would remove $\erssk_r$. The epochs $\hgnodeid_0$ and $\hgnodeid_s$ are connected by a path with the same property. Therefore, if $\hgnodeid_0^\bot$ is not injected, then $\hgnodeid_s$ can be reached, through $\hgnodeid_0^\bot=\hgnodeid_0$, from $\hgnodeid^\bot$ where $\id_s$ is corrupted via a path with above property. This makes the prdicate $\safeIndSecsSecure(\hgnodeid_s, \id_s)$ false, contradicting $\forgesa$.
  Moreover, it is easy to see that if $\hgnodeid_0^\bot$ is injected, then the predicate $\safeWeakAdd(\hgnodeid_s,\id_s)$ would be true, which again makes $\safeIndSecsSecure(\hgnodeid_s, \id_s)$ false.
\end{proof}

By the two claims, with probability at least $\Pr[\forgesa]/(2q_e)$, both $\forgesa$ occurs and $\id_r$ uses $\ersvk_r=\ersvk^*$ (since there are at most $2q_e$ honestly generated keys). It is left to show that if this happens, then $\Bdv[1]$ wins.
\begin{claim}
  If $\forgesa$ occurs and $\ersvk_r=\ersvk^*$, then $\Bdv[1]$ wins.
\end{claim}
\begin{proof}
  Assume $\forgesa$ occurs and $\ersvk=\ersvk^*$. There are two cases: (A) $\id_r$ transitions into an injected epoch $\hgnodeid'$, (B) $\id_r$ is removed.

  In case (A), $\id_r$ checks that $\sigvrf(\ersvk^*, \confTag', \sig)$ is true. Notice that $\confTag'$ uniquely identifies $\hgnodeid'$, because it is derived by hashing $\epochSecret$ which identifies $\hgnodeid$ by definition (see the proof of \saik consistency). Since the epoch is injected and not created by an honest party, no honest party signed $\confTag'$. In particular $\Bdv[1]$ never had to send $\confTag'$ to the sign oracle. Therefore, $\Bdv[1]$ wins with the forgery $(\confTag', \sig)$.

  For case (B), $\id_r$ checks that $\sigvrf(\ersvk^*, (\id_s, \hglr\md\id_r, \confTag),$ $ \sig)$ is true, where $\confTag$ uniquely identifies $\hgnodeid$. $\forgesa$ guarantees that $\id_s$ did not remove $\id_r$ in $\hgnodeid$, so it did not sign such a triple. Therefore, $\Bdv[1]$ wins with $((\id_s, \hglr\md\id_r, \confTag), \sig)$.
\end{proof}

\newcommand{\hybridThreeN}{3$^*$\xspace}
\newcommand{\forgessN}{\forgess\xmath{^*}\xspace}
\headingB{Symmetric forgery.}
We next bound the probability of symmetric forgery.
\begin{lemma}
There exist reductions $\Bdv[2]$ and $\Bdv[3]$ such that
\begin{multline*}
    \Pr[\forgess] \leq \  q_e\cdot \textnormal{Adv}^{\ufcma}_\mac(\Bdv[2]) \\+ q_e^3\log(q_n)\cdot \textnormal{Adv}^\mmowrcca_{\mmPKE,q_e\log(q_n),q_n}(\Bdv[3])\\+\  3q_e^2q_h/2^\kappa .
\end{multline*}
\end{lemma}

At a high level, recall that \forgess occurs for epoch $\hgnodeid$ when the adversary $\Adv$ injects to some $\id_r$ in $\hgnodeid$ a message that either (A) makes $\id_r$ transition to a new injected epoch or (B) removes $\id_r$ although it was not honestly removed. Triggering (A) requires from $\Adv$ computing the confirmation tag which is the hash output on $\hgnodeid$'s $\initSecret$ and the injected epoch's context. Triggering (B) requires forging a MAC under $\hgnodeid$'s secret $\membershipKey$.

To bound the probability of each (A) and (B), we first replace $\hgnodeid$'s $\initSecret$ and $\membershipKey$ by random values, independent of the rest of the experiment. To make this possible, the adversary first commits to the epoch $\hgnodeid$. This results in a security loss of $q_e$ (for guessing the epoch).
Now assuming \mmPKE is secure, the change cannot be noticed as long as $\safeGrpSecsSecure$ in $\hgnodeid$ (part of the \KwConf{} predicate) is true. Since \forgess requires this to be true at the moment it occurs (and the predicate is monotone), the change does not affect the probability that \forgess occurs (for the first time).

Once $\initSecret$ is random, in the ROM, the probability of (A) is negligible. Once $\membershipKey$ is random, the probability of (B) is negligible, assuming that MAC is unforgeable.

Formally, we first define the new hybrid.
\begin{description}
  \item[] {\bf Hybrid \hybridThreeN : } The same as hybrid 3, except at the beginning $\Adv$ announces an epoch $\hgnodeid$ and $\membershipKey$ and $\initSecret$ in $\hgnodeid$ are random and independent.
\end{description}

Further, the following event is analogous to \forgess but in hybrid \hybridThreeN.
\begin{description}
  \item[] {\bf Event \forgessN : } In hybrid \hybridThreeN, there exist two members $\id_s$ and $\id_r$ in $\hgnodeid$ announced by $\Adv$ s.t. $\safeGrpSecsSecure(\hgnodeid)$ and $\forges(\hgnodeid, \id_s, \id_r)$ are true.
\end{description}

Next, we show that changing to hybrid \hybridThreeN does not affect the probability of the bad event much.
\begin{claim}
  There exists a reduction $\Bdv[3]$ such that
  \begin{multline*}
    \Pr(\forgessN) - \Pr(\forgess) \hspace*{16em}\\\leq q_e^3\log(q_n) \cdot
    \textnormal{Adv}^{\mmowrcca}_{\mmPKE,q_e,q_e\log(q_n),q_n}(\Bdv[3]) \\
    + 3q_e^3q_n/2^\kappa.
  \end{multline*}
\end{claim}
\begin{proof}
  First, observe that if $\Adv$ triggers \forgess in hybrid 3 with probability at least $\epsilon$, then $\Adv'$ who guesses $\hgnodeid$ at random triggers \forgessN but in hybrid 3 (i.e., $\membershipKey$ and $\initSecret$ are not random) with probability at least $\epsilon/q_e$.

  Second, observe that $\membershipKey$ and $\initSecret$ are derived the same way as the group key --- each key is the result of hashing the epoch secret with a different label. Therefore, the proof analogous to the proof of \cref{thm:hybrid2} shows that the difference between the probability of \forgessN in hybrid 3 and \forgessN in hybrid \hybridThreeN is bounded by $q_e^2\log(q_n) \cdot \textnormal{Adv}^{\mmowrcca}_{\mmPKE,q_e,q_e\log(q_n),q_n}(\Bdv[3]) + 3q_e^2q_n/2^\kappa$.
\end{proof}

Finally, it is left to bound the probability of \forgessN. To this end, we define two sub-events:
\begin{description}
  \item[] {\bf Event $\forgessN(A)$ : } In hybrid \hybridThreeN, there exist two members $\id_s$ and $\id_r$ in $\hgnodeid$ announced by $\Adv$ such that the predicate $\safeGrpSecsSecure(\hgnodeid)$ is true and (A) $\id_r$ accepts a message that makes it transition to an epoch $\hgnodeid'$ with $\hg[\hgnodeid'].\hginj$ true.
  \item[] {\bf Event \forgessN(B) : } In hybrid \hybridThreeN, there exist two members $\id_s$ and $\id_r$ in $\hgnodeid$ announced by $\Adv$ such that the predicate $\safeGrpSecsSecure(\hgnodeid)$ is true and (B) $\id_r$ accepts a message that removes it but $\id_s$ did not remove $\id_r$ in $\hgnodeid$.
\end{description}

We next bound the probability of each sub-event.
\begin{claim}
  In the ROM, we have
  \begin{equation*}
    \Pr(\forgessN\textnormal{(A)}) \leq q_d/2^\kappa,
  \end{equation*}
  where $q_d$ is the number of delivered messages.
\end{claim}
\begin{proof}
  Recall that $\hgnodeid'$ is identified by its unique epoch secret $\epochSecret'$, computed as the hash of $\initSecret$ of $\hgnodeid$ and the context of $\hgnodeid'$. Since in hybrid \hybridThreeN $\initSecret$ is random and independent of the experiment, so is $\epochSecret'$. Further, recall that $\id_r$ accepts the message only if the attached confirmation tag $\confTag'$ is equal to the hash of $\epochSecret'$ with appropriate label. This matches with probability at most $1/2^\kappa$. The claim follows by the union bound on the number of injection attempts.
\end{proof}

\begin{claim}
  There exists a reduction $\Bdv[2]$ such that
  \begin{equation*}
    \Pr(\forgessN\textnormal{(B)}) \leq \textnormal{Adv}^{\ufcma}_{\mac}(\Bdv[2]).
  \end{equation*}
\end{claim}
\begin{proof}
  $\Bdv[2]$ emulates hybrid \hybridThreeN for $\Adv$, except instead of the MAC key $\members$ in $\hgnodeid$ announced by $\Adv$, $\Bdv[2]$ uses its \ufcma Sign and Verify oracles. Since $\membershipKey$ is random and independent in hybrid \hybridThreeN, $\Bdv[2]$ simulates the experiment perfectly.

  It is left to show that if \forgessN(B) occurs, then $\Bdv[2]$ wins. Assume the event occurs. $\Bdv[2]$ outputs the forgery consisting of the tag $\macsig_t$ from the injected packet removing $\id_r$ and the message $(\id_s, \hglr\md\id_r, \confTag)$ where $\confTag$ is the confirmation tag in $\hgnodeid$. Since $\id_r$ accepted the message, MAC verification passes.

  Finally, we claim that $\Bdv[2]$ did not query this message to the Sign oracle. Observe that this only happens if an honest party in sends out a MAC over $(\id_s, \hglr\md\id_r, \confTag)$. Since only $\id_s$ MAC's its identity and only parties in $\hgnodeid$ MAC $\confTag$, this only happens if $\id_s$ removes $\id_r$ in $\hgnodeid$. This is a contradiction with \forgess(B).
\end{proof}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
