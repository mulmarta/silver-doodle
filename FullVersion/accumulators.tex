% !TEX root = main.tex
% !TeX spellcheck = en_US

\section{Weighted Accumulators}\label{sec:accumulators}
%In this section, we first extend the syntax and security of

%\subsection{Syntax}
A cryptographic accumulator, as introduced in \cite{EC:BenDeM93}, allows to generate a short \emph{accumulated}
representation $\accValue$ of a set and later compute a short proof that an element is in the set represented by
$\accValue$. Weighted accumulators generalize the above notion, in order to allow for more efficient constructions. In
particular, a weighted accumulator allows to generate an accumulated representation of a \emph{weighted} set, i.e., a
set of pairs $(x,w)$, where $w$ is an integer weight. %\footnote{Equivalently,
%  one can define weights over \Q and have the weights sum to 1 by dividing all weights by their sum.}
Later, it is possible to compute a proof that an element $x$ (without weight) is in the weighted set represented by $\accValue$.

Introducing weights allows to define new measures of efficiency. For example, our construction in \cref{sec:build:wacc} optimizes the weighted sum of sizes of all proofs, where the weight of a proof size is the weight of the element whose membership is proved. We stress that weights are irrelevant in the context of security.
%
Formally, the following definition extends the syntax of accumulators from \cite{EC:BarPfi97} to incorporate weights,
but removes the setup algorithm as it isn't necessary for our constructions.
\begin{definition}[Weighted Accumulators]
  A Weighted Accumulator scheme $\wacc$ consists of the following three algorithms:
  \begin{itemize}[align=left, nosep]
  \item[$\waccEval(X)\rightarrow(\accValue, aux)$:] Takes as input a set $X$ of element-weight pairs $(x,w)$, where $w$
    is a positive integer, and (deterministically) outputs an accumulated representation $\accValue$ of $X$ and auxiliary information $\accaux$.
  \item[$\waccProve(\accValue, x, \accaux)\getsl\accProof$:] Generates a proof $\accProof$ that $(x,w) \in X$ for some
    set $X$ with the accumulated representation $\accValue$ and some integer $w$.
  \item[$\waccVrfy(\accValue, x, \accProof)\rightarrow 0\vee 1$:] Verifies the proof $\accProof$ and outputs $1$ for accept or $0$.
  \end{itemize}
\end{definition}


\begin{remark}
  Some works define cyrptographic accumulators with more features. For instance, dynamic accumulators \cite{C:CamLys02} allow to modify $\accValue$ so that elements are added to the represented set. See e.g. \cite{RSA:ATSM09} for an overview. Such features are not required for our application. However, weights can be added to any accumulators if this benefits their application.
\end{remark}

\subsection{Security}
We recall the notion of unforgeability (also called \emph{collision resistant/freeness}) from \cite{RSA:DerHanSla15} (and adapt the syntax to account for weights).
\begin{definition}[Accumulator Unforgeability]\label{def:acc_unforgeability}
  We define the advantage of an adversary \Adv against the
  \emph{unforgeability} of a weighted accumulator \wacc as
  \[
    \adv{\gamefont{UF}}{\wacc}(\Adv) = \Pr
    \left[
      \begin{array}{c}
        \nexists w\in\N : (x,w) \in X \wedge (\accValue, \_) \gets \waccEval(X)\\
        \wedge\ \waccVrfy(\accValue, x, \accProof) = 1
      \end{array}
      \middle\vert
      \begin{array}{c}
        (X, x, \accProof) \gets \Adv
      \end{array}
    \right].
  \]
\end{definition}

\subsection{Efficient Construction from Collision-Resistant Hashing}\label{sec:build:wacc}
\begin{figure}[!t]
  \begin{algobox}{$\huffmanacc[\hash]$}
    \scalebox{.7}{
      \begin{minipage}[t]{.4\linewidth}
        \algoHead{$\waccEval(\{(x_1,w_1), \dots, (x_n,w_n)\})$}
        \begin{algorithmic}
          \State $\tree \gets \algorithm{labeled-huffman}($\\\strut\hfill$(x_1,\ldots,x_n), (w_1,\ldots,w_n))$
          \State $\accValue \gets \tree.\term{root}.\term{label}$
          \State \Return $(\accValue, \accaux = ($\\\strut\hfill$(x_1,\ldots,x_n), (w_1,\ldots,w_n)))$
        \end{algorithmic}
    \end{minipage}}
    \scalebox{.7}{
      \begin{minipage}[t]{.54\linewidth}
        \algoHead{$\waccProve(\accValue, x, \accaux)$}
        \begin{algorithmic}
          \State $\tree \gets \algorithm{labeled-huffman}(\accaux)$
          \State $\accProof \gets ()$
          \State Let $v\in\tree.\leaves$ s.t. $v.\term{label}=\hash(\term{leaf}, x)$.
          \While{$v\neq \tree.\term{root}$}
          \State $v_p \gets v.\term{parent}, (v_L,v_R) \gets v_p.\term{children}$
          \If{$v = v_L$}
          \ $\accProof \listapp (\literal{R}, v_R.\term{label})$
          \Else
          \ $\accProof \listapp (\literal{L}, v_L.\term{label})$
          \EndIf
          \State $v \gets v.\term{parent}$
          \EndWhile
          \State\Return$\accProof$
        \end{algorithmic}
    \end{minipage}}
    \hfill
    \scalebox{.7}{
      \begin{minipage}[t]{.41\linewidth}
        \algoHead{$\waccVrfy(\accValue, x, \accProof)$}
        \begin{algorithmic}
          \State $\hat{h} \gets \hash(\literal{leaf},x)$
          \For{$i=0$ \bf to $\len(\accProof)-1$}
          \If{$\accProof[i]=(\literal L, h)$}
          \State $\hat{h} \gets \hash(\literal{int}, h, \hat{h})$
          \ElsIf{$\accProof[i]=(\literal R, h)$}
          \State $\hat{h} \gets \hash(\literal{int}, \hat h, h)$
          \Else
          \ \Return $0$
          \EndIf
          \EndFor
          \State \Return $\hat h = \accValue$
        \end{algorithmic}
      \end{minipage}
    }

    \scalebox{.7}{
      \begin{minipage}[t]{1.4\linewidth}
        \bigskip

        \hrulefill

        $\algorithm{labeled-huffman}(\vec x, \vec w)$
        \begin{algorithmic}
          \State Initialize $\tree \gets \huffman(\vec x, \vec w)$. Compute the following label for each node $v$ in $\tree$: If $\exists i : v = \tree.\leaves[i]$ then $v.\term{label} = \hash(\literal{leaf}, \vec x[i])$, else $v.\term{label}=\hash(\literal{int}, v.\children[0].\term{label}, v.\children[1].\term{label})$.
          %          \Statex \hspace*{3em}$v.\term{label} = \begin{cases}\hash(\literal{leaf}, \vec x[i]) & \text{if }\exists i : v = \tree.\leaves[i]\\ \hash(\literal{int}, v.\children[0].\term{label}, v.\children[1].\term{label}) & \text{else}\end{cases}$
          Return $\tree$
        \end{algorithmic}
    \end{minipage}}
  \end{algobox}
  \caption{Weighted cryptographic accumulator $\huffmanacc$. The function $\huffman$ computes the Huffman tree; see \cref{sec:huffman}. See also \cref{sec:prelims} for tree-related notation.}% The constants \literal{leaf} and \literal{int} (for an internal node) are used for domain separation.}
  \label{fig:huffman_wacc}
\end{figure}
Our construction combines the accumulator scheme of \cite{ISC:CHKO08} based on Merkle (hash) trees with the idea of Huffman trees (see \cref{sec:huffman}).

The idea of \cite{ISC:CHKO08} is to build a binary Merkle tree $\tree$ on the accumulated set $X$. That is, $\tree$ has
one leaf for each element of $X$. Moreover, each node of $\tree$ has assigned a hash value: the value of a leaf is the
hash of its element $x$, and the value of an internal node is the hash of the concatenated values of its children. The
accumulated representation of $X$ is the value of the root. Membership of an element $x$ is proven by providing the
values of all nodes on the co-path of the path from $x$'s leaf of to the root.
In order to optimize the weighted sum of the sizes of all proofs, in our scheme $\tree$ is not a balanced tree as in
\cite{ISC:CHKO08}, but a Huffman tree with the weights of words set to the weights of the elements of $X$. The formal description of our scheme $\wacc$ is given in \cref{fig:huffman_wacc}.

Huffman Codes are optimal in the sense that the weighted sum of the codeword lengths is minimal. Codeword lengths depend
on the depth of an element in the tree, which is equivalent to proof size in our construction. Therefore, the weighted
accumulator minimizes the weighted sum of proof sizes. For equal weights on all words, a Huffman tree is a balanced
binary tree, so our accumulator collapses to a regular Merkle tree in that case.

In \cref{sec:app-acc} we prove the following theorem.
\begin{restatable}{theorem}{accSec}\label{thm:wacc_sec}
  Let $\huffmanacc[\hash]$ denote the accumulator from \cref{fig:huffman_wacc} instantiated with a function $\hash:\bits^*\rightarrow \bits^\secparam$.
  For any adversary $\Adv$, there exists an adversary $\Bdv$ such that
  \begin{equation*}
    \adv{\gamefont{UF}}{\huffmanacc[\hash]}({\Adv}) \leq \adv{\CR}{\hash}({\Bdv}).
  \end{equation*}
\end{restatable}


\begin{remark}
In our description, generating proofs for all elements $x$ requires recomputing the Huffman tree for each invocation of $\huffmanacc.\waccProve$. We note that in practice, caching the tree is often more efficient.
\end{remark}


\subsection{Other Constructions}
Alternatively to our hash-based construction, cryptographic accumulators, and hence also weighted accumulators, can be
built from various assumptions, e.g. pairing groups \cite{RSA:ATSM09, RSA:LNguyen05, EPRINT:DamTri08}, RSA groups
\cite{EC:BenDeM93, EC:BarPfi97, ICICS:Sander99, C:CamLys02} and recently from lattices \cite{EC:LLNW16,
  ACISP:YAYLX18}. We compare them to our solution in \cref{sec:tdacc}.


% \dnote{Shorten here?}
% One advantage of our construction compared to the above is its computational efficiency, because it does not require
% performing any public-key operations. Another advantage is post-quantum security, which is otherwise only achieved by
% the lattice-based accumulators.

% The main disadvantage of our construction is that its proof size grows logarithmically in the size of the accumulated
% set. However for practical matters, this is mostly irrelevant as even constant size proofs in lattice or RSA
% settings are substantially larger than a logarithmic number of hashes. A more detailed comparison is found in
% \cref{sec:eval} and \cref{sec:tdacc}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
