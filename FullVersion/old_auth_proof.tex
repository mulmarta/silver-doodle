\newcommand{\forges}{\variable{\small Forges}}
\newcommand{\forgesa}{\variable{\small ForgesAsym}}
\newcommand{\forgess}{\variable{\small ForgesSym}}
\subsection{\saik Guarantees Authenticity}\label{sec:protsec5}
The fourth and final Hybrid introduces authenticity, which is formalized by restoring the \KwAuth{} predicate. It is the ideal experiment with $\funcCGKA$.
\begin{description}
\item[] {\bf Hybrid 4: $\ucideal_{\funcCGKA^4, \ucsim^4}$.} The functionality $\funcCGKA^4$ uses the original \KwAuth{} predicate from $\funcCGKA$. The simulator $\ucsim^4$ is the same as $\ucsim^4$.
\end{description}

In the remainder of this section, we show that if $\ers$ is unforgeable (\shrsufcma and \ahrsufcma) and key committing (\rkc) and if $\mmPKE$ is \mmowrcca secure, then \saik guarantees authenticity, that is, hybrids 3 and 4 are indistinguishable. (Security of \mmPKE is used to guarantee secrecy of the symmetric membership keys used by \ers.)

\headingB{Game-based perspective.}
Observe that hybrids 3 and 4 are identical unless an authentic epoch is created by a message injected by $\Adv$. We call this bad event $\forges$. It is easy to see that $\Adv$'s advantage in distinguishing the hybrids is upper bounded by the probability of $\forges$. This means that distinguishing hybrids 3 and 4 can be seen as a typical authenticity game, where the adversary wins by forging messages accepted by the protocol, as expressed by $\forges$.

%\headingB{Simplifications.}
%For this proof sketch (as for confidentiality) we ignore issues related to joining parties. For example, we assume that all $\ers$ asymmetric key pairs are generated by parties creating epochs, and not by the AKS and injected epochs are only created when group members transition to them. One way to think about this is that messages authenticated with keys from the AKS cannot be forged by assumption.

\headingB{Two bad events.}
Let $\Adv$ be any environment. As stated above, hybrids 3 and 4 are identical unless $\Adv$ triggers $\forges$, so the goal is to upper bound the probability that it occurs. %, say, in hybrid 3.
Since epochs in detached trees are not authentic and the root epoch with $\hgnodeid=0$ cannot be injected by definition, in the remainder of the proof we only consider non-root epochs in the main history-graph tree.
Such epochs are authentic in two cases: if in their parent epochs either the group secrets or the individual secrets of their creators are secure. Accordingly, we define two sub-events of $\forges$ depending on which secrets are secure:
\begin{description}
  \item[] {\bf Event $\forgesa$: } There exists an epoch $\hgnodeid$ with parent $\hgnodeid_p$ and creator $\id_s$ such that $\hg[\hgnodeid].\hginj$ and $\safeIndSecsSecure(\hgnodeid_p, \id_s)$ are both true.
  \item[] {\bf Event $\forgess$: } There exists an epoch $\hgnodeid$ with parent $\hgnodeid_p$ such that $\hg[\hgnodeid].\hginj$ and $\safeGrpSecsSecure(\hgnodeid_p)$ are both true.
\end{description}
It remains to bound the probability of each $\forgesa$ and $\forgess$.

\headingB{Notation.}
In case $\forgesa$ or $\forgess$ occurs for epoch $\hgnodeid$ with parent $\hgnodeid_p$, we denote by $\id_s$ the creator of $\hgnodeid$. Further, we let $\id_r$ be the group member accepting the injected message creating $\hgnodeid$ and we let $\ersvk_r$, $k_r$, $\vec m_r$, $\rd_r$ and $\sigma_r$ be the values inputted by $\id_r$ to $\ersvrfyL$ when accepting the message.

\headingB{Asymmetric forgery.}
We next prove the following lemma
\begin{lemma}
There exist reductions $\Bdv[1]$ and $\Bdv[2]$ such that
\begin{equation*}
    \Pr[\forgesa] \leq 2q_e\cdot \textnormal{Adv}^{\ahrsufcma}_\ers(\Bdv[1]) + 2q_e\cdot \textnormal{Adv}^\rkc_\ers(\Bdv[2]).
\end{equation*}
\end{lemma}
%We note that without our simplification where we ignore joiners, the factor $q_e$ would become $2q_e$, as in \cref{thm:itk_secure}.

Both $\Bdv[1]$ and $\Bdv[2]$ run $\Adv$ identically; the only difference between them is in how they find forgeries. Specifically, the reductions emulate hybrid 3 for $\Adv$ and embed the challenge key $\ersvk^*$ as one of the verification keys honestly generated during the execution. Keys are honestly generated when group members create epochs during send: each send introduces one new key pair for the sender and, in case of an add, one for the added member (in this case, it is generated by the AKS at the moment of send). Therefore, there are at most $2q_e$ key pairs.
Which key is replaced by $\ersvk^*$ is chosen at random. The reductions use the Sign oracle to sign honestly sent messages that verify with $\ersvk^*$. If a party holding the corresponding $\erssk^*$ is corrupted, they give up.

The next three claims show that with probability $\Pr[\forgesa]/(2q_e)$, both $\forgesa$ occurs and \mbox{$\ersvk_r=\ersvk^*$} (see notation above). Moreover, if this happens, then one of the reductions wins.

\begin{claim}
  The probability of $\ersvk_r=\ersvk^*$ is at least $\Pr[\forgesa]/(2q_e)$
\end{claim}
\begin{proof}
  We will show that if $\forgesa$ occurs, then $\ersvk_r$ is honestly generated. Since there are at most $2q_e$ honestly generated keys, this proves the claim.

  Assume $\forgesa$ occurs.
  Notice that $\ersvk_r$ is introduced into $\id_r$'s state when it accepts a message from $\id_s$ that transitions it into an ancestor $\hgnodeid_0$ of $\hgnodeid_s$.
  Observe first that $\hgnodeid_0$ is not injected. The reason is that no epoch between $\hgnodeid_0$ and $\hgnodeid_s$ is created by $\id_s$ or removes it, since this would remove $\ersvk_r$ from $\id_r$'s state. So, if $\hgnodeid_0$ was injected, $\safeKnowsSecrets(\hgnodeid_0, \id_s)$ would be true and $\safeIndSecsSecure(\hgnodeid_s, \id_s)$ would be false, which contradicts $\forgesa$.

  This means that $\id_s$ created $\hgnodeid_0$ during a send operation and at that point generated an honest verification key $\ersvk_s$ for itself. We know (from the proof that \saik guarantees consistency) that parties in the same epoch agree on the ratchet tree, which contains all verification keys. Therefore, $\ersvk_r=\ersvk_s$, so $\ersvk_r$ is honestly generated.
\strut\hfill$\Box$\end{proof}

Both reductions lose in case a party holding $\erssk^*$ is corrupted. We next show that under right conditions this does not happen.
\begin{claim}
  If $\forgesa$ occurs and $\ersvk_r=\ersvk^*$, then no party holding $\erssk^*$ is corrupted.
\end{claim}
\begin{proof}
  Assume towards a contradiction that \forgesa occurs, $\ersvk = \ersvk^*$ and a party holding $\erssk^*$ is corrupted in some epoch $\hgnodeid^\bot$. Let $\hgnodeid_0^\bot$ be the epoch before $\hgnodeid^\bot$ which introduces $\erssk^*$ into its state.

  Observe that (honest) parties only store the signing keys that they generate themselves while creating epochs or that the AKS generates for them when they are added. Moreover, such honestly generated keys are not re-computed and the AKS generates a fresh key pair each time a party is added.
  This means that the corrupted party is $\id_s$. Moreover, if $\hgnodeid_0^\bot$ is not injected, then it is the epoch $\hgnodeid_0$ which introduces $\ersvk^*$ into the state of $\id_r$. If, on the other hand, $\hgnodeid_0^\bot$ is injected, then it must add $\id_s$ (and not be created by it).

  Observe further that $\hgnodeid_0^\bot$ and $\hgnodeid^\bot$ are connected by a path of epochs not created by $\id_s$ and not removing it, as this would remove $\erssk^*$. The epochs $\hgnodeid_0$ and $\hgnodeid_s$ are connected by a path with the same property. Therefore, if $\hgnodeid_0^\bot$ is not injected, then $\hgnodeid_s$ can be reached, through $\hgnodeid_0^\bot=\hgnodeid_0$, from $\hgnodeid^\bot$ where $\id_s$ is corrupted via a path with above property. This makes $\safeIndSecsSecure(\hgnodeid_s, \id_s)$ false, contradicting $\forgesa$.
  Moreover, it is easy to see that if $\hgnodeid_0^\bot$ is injected, then $\safeWeakAdd(\hgnodeid_s,\id_s)$ would be true, which again makes $\safeIndSecsSecure(\hgnodeid_s, \id_s)$ false.
\strut\hfill$\Box$\end{proof}

It is left to explain how $\Bdv[1]$ or $\Bdv[2]$ can find a forgery with which it wins.
\begin{claim}
  If $\forgesa$ occurs and $\ersvk_r=\ersvk^*$, then either $\Bdv[1]$ wins with the forgery $k_r$, $\vec m_r$, $\rd_r$ and $\sigma_r$, or there are $k'$ and $\vec m'$ such that $\Bdv[2]$ wins with $k'$, $k_r$, $\vec m'$, $\rd_r$ and $\sigma_r$.
\end{claim}
\begin{proof}
  Assume $\forgesa$ occurs and $\ersvk=\ersvk^*$. Further, assume that $\Bdv[1]$ does not win with $k_r$, $\vec m_r$, $\rd_r$ and $\sigma_r$.
  This can only happen if the \KwReq{} statement in the \ahrsufcma game is violated, i.e., there exists an $\vec m'$ sent to the Sign oracle such that $\vec m_r = \rd_r(\vec m')$. $\Bdv[1]$ only sends $\vec m'$ to the Sign oracle when $\id_s$ creates epochs (since this is the only party signing with the honest $\erssk^*$). Let $\hgnodeid'$ denote the epoch created when $\vec m'$ was sent to Sign, and let $\hgnodeid_p'$ denote the parent of $\hgnodeid'$.

  If $\hgnodeid_p \neq \hgnodeid_p'$, then $k \neq k'$, because membership keys $k$ and $k'$ are derived from epoch keys, which uniquely identify epochs. Therefore, in this case $\Bdv[2]$ wins.

  Finally, we show that $\hgnodeid_p = \hgnodeid_p'$ leads to a contradiction. Observe that in this case, the group state in $\hgnodeid'$ is computed by $\id_s$ who modifies the state in $\hgnodeid_p$ consistently with $\vec m'$. Further, the group state in $\hgnodeid$ is computed by $\id_r$ who also modifies the state in $\hgnodeid_p$, this time consistently with $\vec m_r$ and $\rd_r$. Since $\vec m_r=\rd_r(\vec m')$, these modifications are the same. Therefore, $\hgnodeid=\hgnodeid'$. However, $\hgnodeid$ is injected and $\hgnodeid'$ is honest, which is a contradiction.
\strut\hfill$\Box$\end{proof}


\headingB{Symmetric forgery.}
We next prove the following lemma
\begin{lemma}
There exist reductions $\Bdv[3]$ and $\Bdv[4]$ such that
\begin{equation*}
  \begin{split}
    \Pr[\forgess] \leq &\  q_e\cdot \textnormal{Adv}^{\shrsufcma}_\ers(\Bdv[3]) \\+\ & 3q_e^2q_h/2^\kappa + q_e^3\log(q_n)\cdot \textnormal{Adv}^\mmowrcca_{\mmPKE,q_e\log(q_n),q_n}(\Bdv[4]).
  \end{split}
\end{equation*}
\end{lemma}

At a high level, $\Bdv[3]$ first guesses the epochs $\hgnodeid$ and $\hgnodeid_p$ that make $\forgess$ occur. Then, it emulates hybrid 3 for $\Adv$, except instead of the membership key in $\hgnodeid_p$, $\Bdv[3]$ uses its \shrsufcma Sign and Verify oracles. The fact that $\safeGrpSecsSecure(\hgnodeid_p)$ is true will ensure that if $\Adv$ distinguishes $\Bdv[3]$'s emulation from hybrid 3, then a reduction $\Bdv[4]$ wins the \mmowrcca game. Further, the fact that $\hgnodeid$ is injected will ensure that $\Bdv[3]$ wins. A formal proof follows.

Consider the following experiments.
\begin{description}
  \item[] {\bf Hybrid 3.1 : } The same as hybrid 3, except at the beginning $\Adv$ announces an epoch $\hgnodeid_p$ and the experiment stops as soon as $\KwConf{}(\hgnodeid_p)$ becomes false.
  \item[] {\bf Hybrid 3.2 : } The same as hybrid 3.1, except the membership key $\membershipKey$ in $\hgnodeid_p$ announced by $\Adv$ is random and independent.
\end{description}
Further, we define events analogous to $\forgess$ but in hybrids 3.1 and 3.2:
\begin{description}
  \item[] {\bf Events $\forgess_i$ for $i\in\{1,2\}$ : } At the end of hybrid $i$, there exists an epoch $\hgnodeid$ with parent $\hgnodeid_p$ announced by $\Adv$ such that $\setvert[\hgnodeid].\hginj$ is true.
\end{description}

Clearly, for the environment $\Adv'$ that guesses $\hgnodeid_p$, we have $\Pr[\forgess[1]] \geq 1/q_e \cdot \Pr[\forgess]$. It remains to upper bound $\Pr[\forgess[1]] $. We do this in two steps, formalized by the next two claims.

\begin{claim}
  There exists a reduction $\Bdv[2]$ such that
  \begin{equation*}\begin{split}
    \Pr(\forgess_2) - \Pr(\forgess[1]) \hspace*{16em}\\\leq q_e^2\log(q_n) \cdot \textnormal{Adv}^{\mmowrcca}_{\mmPKE,q_e,q_e\log(q_n),q_n}(\Bdv[2]) + 3q_e^2q_n/2^\kappa.
  \end{split}\end{equation*}
\end{claim}
\begin{proof}
  Observe that the membership key is derived the same way as the group key --- each key is the result of hashing the epoch secret with a different label. Therefore, the proof is analogous to the proof of \cref{thm:hybrid2}.
\strut\hfill$\Box$\end{proof}

\begin{claim}
  There exists a reduction $\Bdv[1]$ such that
  \begin{equation*}
    \Pr(\injectsB_2) \leq \textnormal{Adv}^{\shrsufcma}_{\ers}(\Bdv[1]).
  \end{equation*}
\end{claim}
\begin{proof}
  $\Bdv[1]$ emulates hybrid 3.2 for $\Adv'$, except instead of the membership key in $\hgnodeid_p$ announced by $\Adv'$, $\Bdv[1]$ uses its \shrsufcma Sign and Verify oracles. Observe that $\KwConf{}(\hgnodeid_s)$ is always true, so no party is corrupted in $\hgnodeid_p$. Membership keys are unique per epochs, so this means that the key from $\Bdv[1]$'s game is not leaked upon corruption. Therefore, $\Bdv[1]$ simulates the experiment perfectly.

  If $\forgess_2$ occurs for a child $\hgnodeid$ of $\hgnodeid_p$, $\Bdv[1]$ halts and sends to the challenger $\ersvk$, $\vec m$, $\rd$ and $\sigma$ inputted by an $\id_r$ who transitioned to $\hgnodeid$ from $\hgnodeid_p$ as a current group member (i.e., $\id_r$ does not join into $\hgnodeid$). Note that there must be such a member, because $\hgnodeid_p$ is injected, so it is created when an $\id_r$ receives a message and it is not in a detached tree, so it must have been attached when some $\id_r$ transitioned there from the main tree.

  Assume towards a contradiction that $\Bdv[1]$ does not win with the above solution. Since $\id_r$ checked that the \ers verification outputs 1, this can only happen if $\Bdv[1]$ sent to the Sign oracle a $\vec m'$ such that $\vec m = \rd(\vec m')$. $\Bdv[1]$ uses the oracle only for messages sent by parties in $\hgnodeid_p$ (since membership keys are unique). Therefore, $\vec m'$ was sent to the oracle when some $\id_s$ created an epoch $\hgnodeid'$ as a child of $\hgnodeid_p$.
  Observe that the group state in $\hgnodeid'$ is computed by $\id_s$ who modifies the state in $\hgnodeid_p$ consistently with $\vec m'$. Further, the group state in $\hgnodeid$ is computed by $\id_r$ who also modifies the state in $\hgnodeid_p$, this time consistently with $\vec m_r$ and $\rd_r$. Since $\vec m_r=\rd_r(\vec m')$, these modifications are the same. Therefore, $\hgnodeid=\hgnodeid'$. However, $\hgnodeid$ is injected and $\hgnodeid'$ is honest, which is a contradiction.
\strut\hfill$\Box$\end{proof}