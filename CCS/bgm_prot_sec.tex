% !TEX root = main.tex
% !TeX spellcheck = en_US

\section{Details of \saik} \label{sec:saik-details}
\input{fig_state}
In this section we give the details of the \saik protocol. The pseudocode can be found in \cref{fig:prot1,fig:prot-helpers2}.

\subsection{Ratchet Trees}
\input{prot_ratchet_tree}

\subsection{\saik State and Algorithms}
\input{prot_state}

%\subsection{\saik Algorithms}
\saik's algorithms are defined in \cref{fig:prot1,fig:prot-helpers2}. Apart from initialization, there are three main algorithms (the rest of the code are subroutines) exposed to a user (or a higher-level application). They are identified by keywords \keyword{Send}, \keyword{Receive} and \keyword{Key}, respectively. First, \keyword{Send} is used to create a new epoch. When the user inputs \keyword{Send} followed by the intended group modification (update, add or remove), the protocol applies the modification and returns a message, which the user can upload to the mailboxing service. Second, \keyword{Receive} is used to process messages downloaded from the service. Third, with \keyword{Key} user gets the current group key.

The formal syntax of saCGKA protocols is defined as part of our security definition in \cref{sec:model}. In particular, an saCGKA protocol must expose the same interface as the ideal CGKA functionality.

\input{fig_prot}

\newcommand{\extract}{\method{extract}}
\newcommand{\getExtractionIndices}{\method{getExtractionIndices}}
\subsection{Extraction Procedure for the Server}
Finally, we describe a procedure $\extract(C, \id) \to c$ used by the mailboxing service to take an uploaded message $C$
and compute the message $c$ delivered to user $\id$. Formally, this procedure is not part of our syntax or security
definitions, since for simplicity our model does not consider correctness (see \cref{sec:simplifications}) and an
untrusted service can anyway deliver arbitrary messages. It is formally defined in \cref{fig:saik-extraction-alg}.

\input{fig_extract_alg}

Recall that $C$ contains the executed group operation $\hgact$ and the sender $\id_s$, a multi-recipient ciphertext $Ctxt$ and a vector of updated public keys $\updatedPks$. Roughly, $\extract$ only needs to compute $\id$'s individual mmPKE ciphertext $\mmpkeExtL(Ctxt, i)$ and the prefix of the first $j$ elements of $\updatedPks$. This requires that it knows the indices $i$ and $j$ for $\id$.
%
We notice that they can be easily computed using the public part of the ratchet tree, $\hgact$ and $\id_s$. Therefore, the indices can be obtained in two ways. First, the service can send $\hgact$ and $\id_s$ to $\id$, who replies with $i$ and $j$.  This requires interaction, but both $\id$ and the service are online at the time. Second, the service can store the current ratchet trees and compute $i$ and $j$ itself. The disadvantage of this is that it requires keeping a large state --- in case members are out of sync (e.g. a user is 10 epochs behind), the service needs to store one tree for each epoch which has an active member in it.
%
Once $i$ and $j$ are known, $\extract$ works as follows.

If $\hgact = \hglu$, set  $ctxt = \mmpkeExtL(Ctxt, i)$ and $\redactedUpPks = (\updatedPks[1], \dots, \updatedPks[j])$. Output $c =  (\id_s, \hgact, \pathSecCtxtInd,\allowbreak  \redactedUpPks,\allowbreak  \sig)$, where $\sig$ is a field of $C$. If $\hgact = \hglr\md\id$, output $c =  (\id_s, \literal{removed}, \sig_t, \macsig_t)$ where $ \sig_t$ and $\macsig_t$ are taken from $C$. Finally, if $\hgact = \hgla\md\id$, $C$ contains $\variable{welcomeData}$, which in turn contains a ratchet tree. Based on this, compute $\id$'s index $i$ in $Ctxt$,  the number $n$ of recipients of $Ctxt$, and then $ctxt_1 = $ $\mmpkeExtL(Ctxt, i)$ and $ctxt_2 = \mmpkeExtL(Ctxt, n+1)$. Output $c =  (\id_s, \hgact, \encGroupSecret_1,\allowbreak  \encGroupSecret_2,\allowbreak  \variable{welcomeData})$.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
