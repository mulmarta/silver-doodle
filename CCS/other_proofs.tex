\section{Security of the mmPKE Scheme}

% \subsection{Proof of \cref{thm:wacc_sec}}\label{sec:app-acc}
% \accSec*


% \begin{proof}
%   Let \Adv be any adversary against the unforgeability of \wacc. We construct an adversary \Bdv against the collision
%   resistance of $\hash$ with roughly the same runtime and the same success probability as \Adv.

%   \Bdv simulates the unforgeability game for \Adv by simply forwarding the description of its hash function. Upon
%   receiving a successful forgery $(\vec{X^*}, \vec{w^*}, \accProof^*, x^*)$, \Bdv recomputes the accumulator value
%   $\accValue^* = \accEval(\vec{X^*}, \vec{w^*})$, which rebuilds the Huffman tree $\tree$ and computes the hashes along its
%   paths. Since we assume that \Adv outputs a valid forgery, $\accVrfy(\accValue^*, x^*, \accProof^*)=1$ but $x^*\not\in\vec{X^*}$. Let $\hat h_1, \dots \hat h_\ell$ denote the hashes computed during $\accVrfy$. Since $\accVrfy$ returns $1$, we have $\hat{h}_\ell = \tree.\term{root}.\term{label}$. Since also$x^*\not\in\vec{X^*}$, there exists a node $v$ in $\tree$ and $i$ s.t. $\hat{h}_i = v.\term{label}$ and either $v$ is a leaf or for $v_l, v_r \in v.\term{children}:
%   \hat{h}_{i-1}\neq v_l.\term{label}\wedge \hat{h}_{i-1}\neq v_r.\term{label}$. If $v$ is an internal node, then \Bdv
%   outputs $(\literal{int}, v_l.\term{label}, v_r.\term{label}), (\literal{int},\hat{h}_{i-1}, \pi[i])$ (resp. $(\literal{int},
%   v_l.\term{label}, v_r.\term{label}), (\literal{int},\pi[i],\hat{h}_{i-1})$) as its forgery. If $v$ is the leaf corresponding
%   to $x_i\in\vec{X^*}$, then $\Bdv$ outputs $(\literal{leaf}, x_i),(\literal{int},\hat{h}_{i-1}, \pi[i])$ (respectively,  $(\literal{leaf}, x_i),(\literal{int},\pi[i],\hat{h}_{i-1})$) as its forgery, if $i \neq 0$ or $(\literal{leaf}, x_i), (\literal{leaf}, x^*)$ otherwise.
%   In either case, \Bdv finds a collision if \Adv outputs a valid forgery.
%   \strut\qed\end{proof}

\begin{figure}[!tbp]
  \center
  \begin{algobox}{$\dhmmpke[\Grp, g, p, \dem, \hash]$}
    \begin{minipage}[t]{.49\linewidth}
      \algoHead{\mmpkeKeyGen}
      \begin{algorithmic}
        \State $x\getsr \Z_p$
        \State \Return $(\mmpkesk= g^x, \mmpkepk=x)$
      \end{algorithmic}
      \medskip
      \algoHead{$\mmpkeDec(\mmpkesk_i, c = (c_0, c_i))$}
      \begin{algorithmic}
        \State $k = \hash(c_0^{\mmpkesk_i}, \mmpkepk_i, i)$
        \State \Return $\dem.\demDec(k, c_i)$
      \end{algorithmic}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{.49\linewidth}
      \algoHead{$\mmpkeEnc(\vec{\mmpkepk}, \vec{m})$}
      \begin{algorithmic}
        \State $r \getsr \Z_p$
        \For{$i\in[\abs{\vec m}]$}
          \State $k \gets \hash(\mmpkepk_i^r, \mmpkepk_i, i)$
          \State $c_i = \dem.\demEnc(k, m_i)$
        \EndFor
        \State \mbox{\Return $(c_0=g^r,c_1,\ldots,c_n)$}
      \end{algorithmic}

      \algoHead{$\mmpkeExt(i, C = (c_0,\ldots, c_n))$}
      \begin{algorithmic}
        \State \Return $(c_0, c_i)$
      \end{algorithmic}
    \end{minipage}
  \end{algobox}
  \caption{The mmPKE scheme based on Diffie-Hellman from \cite{ASIACCS:PinPoeSch14}. The scheme requires a group $\Grp$ of
    prime order $p$ generated by $g$, a data encapsulation mechanism $\dem$ and a hash function $\hash$.}
  \label{fig:mmpke_constr}
\end{figure}


\label{sec:app-mmpke}
\mmpkeSecurity*

\begin{proof}
  We define $n$ hybrids $G_0$ through $G_n$, where $G_0$ is identical to $\text{Exp}^{\mmindrcca}_{\mmPKE, \nUsers, 0}$,
  $G_n$ is identical to $\text{Exp}^{\mmindrcca}_{\mmPKE, \nUsers, 1}$ and in $G_i$, the first $i$ challenge ciphertexts
  contain encryptions of $\vec{m}_1$ and the others from $\vec{m}_0$.
  \begin{figure*}[!tbp]
  	\center
  	\begin{gamebox}{$G_{i,1}$}
  		\begin{minipage}[t]{.4\linewidth}
  			\algoHead{Game $G_{i,1}$}
  			\begin{algorithmic}
  				\For{$\idxUser\in[\nUsers]$}
  				$(\mmpkepk_\idxUser, \mmpkesk_\idxUser)\gets \mmpkeKeyGen$
  				\EndFor
  				\State $\term{Corr} \gets \emptyset, \term{HL}\gets \emptyset$
  				\State $(\vec\mmpkepk^*,\vec m_0^*,\vec m_1^*,\mathit{st}) \gets \mathcal A_1^{\text{Dec}_1, \text{Cor},
  					\text{H}}(g, \mmpkepk_1, \dots, \mmpkepk_\nUsers)$
  				\State Parse $\vec\mmpkepk^*$ as $\hat{\mmpkepk}_{i_1},\ldots, \hat{\mmpkepk}_{i_l}, \mmpkepk_{l+1}^*,\ldots,\mmpkepk_n^*$
  				for $l\in [n]$
  				\State s.t. $\forall j\in[l]: \vec m_0[i_j] \neq \vec m_1[i_j]\wedge \hat\mmpkepk_{i_j} \in\vec\mmpkepk$
  				\State \KwReq{} $\abs{\vec m_0^*}=\abs{\vec m_1^*}=\abs{\vec\mmpkepk^*}=n$
  				\State $r \getsr \Zp, c^*_0 \gets g^r$
  				\For{$1\leq j \leq n$}
  				] $K_j \gets H(\mmpkepk_j^r,\mmpkepk_j,j)$
  				\EndFor
  				\State $K^* \getsr \demKeyset$
  				\State $K_i \gets K^*$
  				% \For{$1 \leq j \leq \max(i, l)$}
  				% \State $K_j \getsr \demKeyset$
  				% \EndFor
  				% \For{$\min(l, i+1) \leq j \leq n $}
  				% \State $K_j \gets H(\mmpkepk_j^r,\mmpkepk_j,j)$
  				% \EndFor
  				\For{$1 \leq j \le i$}
  				$c^*_j = \demEnc(K_j, \vec m_1^*[j])$
  				\EndFor
  				\For{$i \leq j \leq n$}
  				$c^*_j = \demEnc(K_j, \vec m_0^*[j])$
  				\EndFor
  				\State $c^* \gets (c^*_0,\ldots, c^*_n)$
  				\State $b \gets \mathcal A^{\text{Dec}_2, \text{Cor}, \text{H}}(c^*,\mathit{st})$
  				
  				\State \KwReq{} $\forall j\in[n] :\vec \mmpkepk^*[j] \notin \{\mmpkepk : i\in[\nUsers] \setminus \term{Corr}\} \implies m_0^*[j]=m_1^*[j]$
  				\State \Return $b$
  			\end{algorithmic}
  		\end{minipage}
  		\hfill
  		\begin{minipage}[t]{.31\linewidth}
  			\algoHead{Oracle Dec$_1(i,(c_0, c_i))$}
  			\begin{algorithmic}
  				\State \KwReq{} $\idxUser\in[\nUsers]$
  				\State $K \gets H(c_0^{\mmpkesk_i}, \mmpkepk_i, i)$
  				\State \Return $\demDec(K, c_i)$
  			\end{algorithmic}
  			
  			\medskip
  			\algoHead{Oracle Dec$_2(j,c = (c_0, (c_k, k)))$}
  			\begin{algorithmic}
  				\State \KwReq{} $j\in[\nUsers]$
  				\State $K \gets H(c_0^{\vec\mmpkesk[j]}, \vec\mmpkepk[j], k)$
  				\If{$c_0 = c_0^* \wedge \vec\mmpkepk^*[k] = \vec\mmpkepk[j] \wedge i \leq l$}
  				\State $K \gets K^*_j$
  				\EndIf
  				\State $m \gets\demDec(K, c_k)$
  				\If{$\exists k : \vec\mmpkepk^*[j] = \mmpkepk_k \land m \in \{\vec m_0^*[j], \vec m_1^*[j]\}$}
  				\State \Return $\keyword{test}$
  				\Else
  				\State \Return $m$
  				\EndIf
  			\end{algorithmic}
  			
  		\end{minipage}
  		\hfill
  		\begin{minipage}[t]{.25\linewidth}
  			\algoHead{Oracle Cor$(\idxUser)$}
  			\begin{algorithmic}
  				\State \KwReq{} $\idxUser\in[\nUsers]$
  				\State $\term{Corr} \setadd \idxUser$
  				\State \Return $\mmpkesk_\idxUser$
  			\end{algorithmic}
  			\medskip
  			\algoHead{Oracle H$(Z, W, i)$}
  			\begin{algorithmic}
  				\If{$\term{HL}[Z,W,i] = \bot$}
  				\State $\term{HL}[Z,W,i] \getsr \demKeyset$
  				\EndIf
  				\State \Return $\term{HL}[Z,W,i]$
  			\end{algorithmic}
  		\end{minipage}
  	\end{gamebox}
  	\caption{Description of the hybrid $G_{i,1}$}
  	\label{fig:mmpke_hybrids_1}
  \end{figure*}
 \begin{figure*}
	\center
	\begin{algobox}{Adversary \Bdv[1] on \sdh}
		\begin{minipage}[t]{.49\linewidth}
			\algoHead{Adversary $\Bdv[1](\Grp, p, g, U, V)$}
			\begin{algorithmic}
				\State $\term{Corr} \gets \emptyset, \term{HL}\gets \emptyset, \term{DL}\gets \emptyset$
				\For{$j \in[\nUsers]$}
				\State Pick $b[j]\gets\bits$ with $\Pr[b[j] = 1] = \frac{1}{q_C}$
				\State $\alpha_j \getsr \Zp\setminus\{0\}$
				\If{$b[i] = 1$}
				 $\mmpkepk_j \gets V^{\alpha_j}$ \Comment{Embed the challenge}
				\Else
				 \ $\mmpkepk_j \gets g^{\alpha_j}$ \Comment{Allow corruption}
				\EndIf
				\EndFor
				\State $\term{Phase} \gets 1$
				\State $(\vec m_0^*,\vec m_1^*,\vec \mmpkepk^*, st) \getsr \Adv^{\term{H},\term{D}_1,\term{Cor}}(\mmpkepk_1,\ldots,\mmpkepk_\nUsers)$
				\State \KwReq{} $\abs{\vec m_0} = \abs{\vec m_1} = \abs{\vec \mmpkepk^*} = n$
				\State Parse $\vec\mmpkepk^*$ as $\hat\mmpkepk_{i_1},\ldots, \hat\mmpkepk_{i_l}, \mmpkepk_{l+1}^*,\ldots,\mmpkepk_n^*$
				for $l\in [n]$
				\State s.t. $\forall j\in[l]: \vec m_0[i_j] \neq \vec m_1[i_j]\wedge \hat\mmpkepk_{i_j} \in\vec\mmpkepk$
				\If{$b[i_i] = 0$}
				\State $\term{Bad}_3 \gets True$
				\State \term{abort}
				\EndIf
				\State $c_0^* \gets U$
				\For{$j\in [n]$}
				\State $K_j\getsr \demKeyset$
				\State $c_j^* \gets \demEnc(K_j, \vec m_b[j])$
				\If{$\exists k\in[N]: \mmpkepk_k = \vec\mmpkepk^*[j] \wedge k < i\wedge b[k] = 1$}
				\State $\term{DL}[j, U, (c_j, j)] = K_j$
				\EndIf
				\If{$j > i \wedge b[j] = 0$}
				\State $\term{HL}[U^{\alpha_j}, \mmpkepk^*[j], j] \gets K_j$
				\EndIf
				\EndFor
				\State $\term{Phase} \gets 2$
				\State $b' \getsr \Adv^{\term{H},\term{D}_2,\term{Cor}}(c_0^*,\ldots, c_n^*, st)$
				\State \Return $\bot$
			\end{algorithmic}
			
			\medskip
			\algoHead{Oracle $\term{Cor}(j)$}
			\begin{algorithmic}
				\State $\term{Corr}\setadd j$
				\If{$b[j] = 1$}
				\State $\term{Bad}_3 \gets True$
				\State \term{abort}
				\EndIf
				\State \Return $\alpha_j$
			\end{algorithmic}
		\end{minipage}
		\hfill
		\begin{minipage}[t]{.49\linewidth}
			\algoHead{Oracle $H(Z, W, j)$}
			\begin{algorithmic}
				\If{$\exists k\in[\nUsers]: W = \mmpkepk_k\wedge \mmpkepk_k = \mmpkepk^*[i] \wedge b[k] = 1 \wedge \oracle{O}_v(U^{\alpha_k}, Z) = 1$}
				 \Return $Z^{\frac{1}{\alpha_k}}$
				\EndIf
				\If{$\term{Phase} = 1 \wedge \oracle{O}_u(W,Z) = 1$}
				\State $\term{Bad}_2 \gets 1$
				\State \term{abort}
				\EndIf
				\If{$\term{Phase} = 2 \wedge j\in [n] \wedge W = \mmpkepk^*[j] \wedge \oracle{O}_u(W,Z)=1 \wedge j > i$}
				\State \Return $K_j$
				\EndIf
				\If{$\exists j \in [\nUsers], c\in\Grp, t\in\demKeyset: W = \mmpkepk_j\wedge \term{DL}[i,(c, (*, j))] = t\wedge
					\oracle{O}_v(c^{\alpha_j},Z) = 1$}
				\State \Return $t$
				\EndIf
				\If{$\term{HL}[Z,W, j] = \bot$}
				\State $\term{HL}[Z,W,j]\getsr \demKeyset$
				\EndIf
				\State \Return $\term{HL}[Z,W,j]$
			\end{algorithmic}
			\medskip
			\algoHead{Oracle $D_{\term{Phase}}(i, (c_0, (c, j)))$}
			\begin{algorithmic}
				\State \KwReq{} $i\in[\nUsers]$
				\If{$\term{Phase} = 1\wedge c_0 = U$}
				\State $\term{Bad}_1 \gets 1$
				\State \term{abort}
				\EndIf
				\If{$\exists Z\in\Grp, t\in\demKeyset: \term{HL}[Z,\mmpkepk_j,j] = t \wedge (b[j] = 0 \implies Z =
					\mmpkepk_j^{\alpha_j} \wedge b[j] = 1 \implies \oracle{O}_v(c^{\alpha_j},Z) = 1)$}
				\State $m \gets \demDec(t, c)$
				\If{$\exists k\in[N]: \vec\mmpkepk^*[j] = \mmpkepk_k \land m \in \{\vec m_0^*[j], \vec m_1^*[j]\}$}
				\State \Return $\keyword{test}$
				\Else
				\State \Return $m$
				\EndIf
				\EndIf
				\If{$\term{DL}[i,(c_0(c,j))] = \bot$}
				\State $\term{DL}[i,(c_0, (c,j))] \getsr \demKeyset$
				\EndIf
				\State $ m \gets \demDec(\term{DL}[i, (c_0,j)], c)$
				\If{$\exists k\in[N]: \vec\mmpkepk^*[j] = \mmpkepk_k \land m \in \{\vec m_0^*[j], \vec m_1^*[j]\}$}
				\State \Return $\keyword{test}$
				\Else
				\State \Return $m$
				\EndIf
				
			\end{algorithmic}
		\end{minipage}
	\end{algobox}
	\caption{Description of adversary \Bdv[1] from \cref{thm:mmpke_security}.}
	\label{fig:mmpkeBdv1}
\end{figure*}
  Additionally, for $i\in[n]$, we define the four hybrids $G_{i,0}$ to $G_{i,3}$. $G_{i,0}$ and $G_{i,3}$ are identical
  to $G_i$ and $G_{i+1}$ respectively. In $G_{i,1}$, we set the $i$-th DEM key to a random key and in $G_{i,2}$ we swap
  the plaintext in the $i$-th challenge ciphertext from $\vec{m}_0[i]$ to $\vec{m}_1[i]$.
  We will split the proofs into the following lemmas.
  \begin{lemma}\label{lem:mmpke_hop1}
    Let $n\in\N$. For all $1\leq i \le n$, there exists an adversary \Bdv[1] against the \sdh assumption s.t. for all adversaries \Adv
    \begin{multline*}
      \abs{\Pr[G_{i,0}(\Adv)\Rightarrow 1]- \Pr[G_{i,1}({\Adv}) = 1]} \leq \\
      e^2q_C\cdot\adv{\sdh}{\Group}({\Bdv[1]}) + \frac{q_{D_1}}{p} + \frac{q_H}{p},
    \end{multline*}
    where $q_H, q_C$ and $q_{D_1}$ denote the number of hash queries, corruption queries and decryption queries in phase
    1 respectively made by $\Adv$.
  \end{lemma}
  \begin{remark}
    Since the changes from $G_{i,2}$ to $G_{i,3}$ are the same as from $G_{i,0}$ to $G_{i,1}$, Lemma~\ref{lem:mmpke_hop1} applies there as
    well.
  \end{remark}

  \begin{lemma}\label{lem:mmpke_hop2}
    Let $n\in\N$. Then for all $1\leq i \le n$, there exists an adversary \Bdv[2] against the \indrcca security of \dem s.t. for all adversaries \Adv
    \[
      \abs{\Pr[G_{i,1}^{\Adv}\Rightarrow 1]-\Pr[G_{i,2}^{\Adv}\Rightarrow 1]} \leq \adv{\indrcca}{\dem}({\Bdv[2]})
    \]
  \end{lemma}

  Combining the two lemmas and the remark yields \cref{cor:mmpke3}. The theorem follows by a standard hybrid
  argument over $G_i$.

  \begin{corollary}\label{cor:mmpke3}
    Let $n\in\N$. Then for all $1\leq i \le n$, there exist adversaries \Bdv[1], \Bdv[2] against the \sdh assumption and
    the \indrcca security of \dem respectively s.t. for all adversaries \Adv
    \begin{multline*}
      \abs{\Pr\left[G_i^{\Adv}\Rightarrow 1\right] - \Pr\left[G_{i+1}^{\Adv}\Rightarrow 1\right]} \leq  \adv{\indrcca}{\dem}({\Bdv[2]}) \\
      \begin{array}{c}
        +\ 2(e^2q_C\cdot\adv{\sdh}{\Group}({\Bdv[1]}) + \frac{q_{D_1}}{p} + \frac{q_H}{p}) \\
      \end{array}
    \end{multline*}
    with $q_{D_1}, q_C$ and $q_H$ from Lemma~\ref{lem:mmpke_hop1}.
  \end{corollary}

  So all that is left is proving the lemmas.
  We will start by proving Lemma~\ref{lem:mmpke_hop1}. Consider the formal definition of $G_{i,1}$ in \cref{fig:mmpke_hybrids_1}.
  

  Next, we describe adversary $\Bdv[1]$ against the \sdh assumption in \cref{fig:mmpkeBdv1}
  First, we argue that $\Bdv[1]$ simulates the game $G_{i,1}$ perfectly, unless one of the events $\term{Bad}_1$ or
  $\term{Bad}_2$ occurs. We will bound the probabilities of these events happening. The games differ only in the
  secret key of the $i$-th message, therefore $G_{i,0}$ and $G_{i,1}$ are identical to
  \Adv, unless it queries the hash oracle on $(Z, U, i)$ as in line 1 of $\term{H}$. If the
  corresponding public key was a key in which the challenge was embedded, i.e. $\term{Bad}_3$ is false, \Bdv[1] breaks
  the \sdh assumption.

  $\term{Bad}_1$ and $\term{Bad}_2$ prevent that $\Adv$ already knows the challenge randomness before its challenge
  query. If it doesn't know this value, all answers of \Bdv[1] to both oracles are distributed as in the real games $G_{i,0}$
  and $G_{i,1}$. Specifically, the oracles are kept consistent and the hash oracle is programmed such that the keys chosen
  for the adversaries challenge are included at the right points.

  $\term{Bad}_3$ occurs if \Adv tries to corrupt a public key for which \Bdv[1] doesn't know the corresponding secret
  key or \Adv chooses a key without the challenge embedded for the $i$-th message. If the first part doesn't happen, the
  corruption oracle is simulated perfectly. The adversary doesn't notice the second part in this case, but if it occurs,
  \Bdv[1] isn't successful, so it is still a bad case for the simulation.

  Now we bound the probability of these events occurring. Since $Y$ is completely hidden from \Adv, it can only find it by
  guessing. Therefore, for an adversary \Adv making at most $q_H$ (resp. $q_{D_1}$) hash (resp. decryption) queries,
  \begin{align*}
    \Pr[\term{Bad}_1 = \text{True}] &\leq \frac{q_{H}}{p} \\
    \Pr[\term{Bad}_2 = \text{True}] &\leq \frac{q_{D_1}}{p}
  \end{align*}

  For $\term{Bad}_3$, consider the probability with which $b[j] = 1$. This is independent for each public key
  $\mmpkepk_j$, so the probability that $\term{Bad}_3$ does \emph{not} occur is the case that for $q_C$ public keys
  $\mmpkepk_{i_1},\ldots,\mmpkepk_{i_{q_C}}$ $b[i_j] = 0$ and for one public key the bit is $1$, so
  \[
    \Pr[\term{Bad}_3 = \term{False}] = (1-\frac{1}{q_C})^{q_C}\cdot \frac{1}{q_C} \overset{(1)}{\leq} \frac{1}{e^2q_C}
  \]
  For $(1)$, we use that $\ln(1+x) \geq \frac{x}{x+1}$ for all $x \geq -1$ and rewrite $(1-\frac{1}{q_C})^{q_C} =
  e^{\ln((1-\frac{1}{q_C})^{q_C})} = e^{q_C\cdot\ln(1-\frac{1}{q_C})} \geq e^{-1/(1-\frac{1}{q_C})} \geq e^{-2}$ for
  $q_C > 1$.
  Combining the probabilities yields the lemma.

  The proof of Lemma~\ref{lem:mmpke_hop2} is a straight forward application of the \indrcca security of the \dem. Since the
  key at position $i$ is random, an \indrcca adversary can simulate encryptions for this position with its encryption
  oracle and embeds its own challenge at the $i$-th challenge ciphertext for the adversary \Adv. If \Adv can distinguish
  between $G_{i,1}$ and $G_{i,2}$ then \Bdv[2] distinguishes its challenges as well.
\end{proof}


% \subsection{Proof for \cref{thm:acc_sec}}\label{sec:app-hrs}
% \hrsSecurity*


% \begin{proof}
%   The proof for \cref{eq:hrs-sec2} is analogue to \cref{eq:hrs-sec1}, therefore we will only describe the latter.
%   Let \Adv[1] be an adversary against the \ahrsufcma security of \ers. We construct the adversaries $\Bdv[1], \Bdv[2],
%   \Bdv[3]$ against the respective primitives as follows:

%   \begin{itemize}[align=left]
%   \item[\underline{{\Bdv[1]} against \ufcma of \sigscheme}:] \Bdv[1] receives a verification key $\spk$ as input and has
%     access to a signing oracle $\mathcal{O}_{\text{sign}}$. \Bdv[1] forwards $\spk$ to \Adv[1] and simulates its signing
%     queries by executing the regular signing algorithm with the exception of getting the signature by querying its
%     signing oracle on the final hash and the tag $(h^{(i)}||\mtag^{(i)})$ (for the $i$-th signing query) with the
%     verification key and uses the symmetric keys provided by the adversary. Eventually, \Adv[1] outputs a (potentially
%     reduced) forgery
%     $(\vec{m^*}, \sigma^* = (\sigma'^*, \mtag^*,\accValue^*(,\accProof^*, h_i^*)), \spk^*, k^*,
%     \rd^*=(\ell^*,*,*)$. \Bdv[1] computes the hash $h^* = \hash(\ell^*|| \accValue|| h_1^*)$ and outputs
%     $(h^*||\mtag^*), \sigma^*$ as its forgery.

%     We analyse \Bdv[1]'s winning probability: Since \Adv[1] outputs a valid forgery, $\vec m^*$ is distinct from all
%     previous message vectors queried to the sign oracle. \Adv[1] controls the symmetric key $k^*$, so we can't assume
%     that $\mtag^*$ is fresh, so $h^*$ has to be a new hash value in order for $\Bdv[1]$ to be successful. However for
%     $h^*$ to be a previous hash while $\vec m^*$ is different from all previous queries, \Adv[1] has to produce either a
%     hash collision or an accumulator forgery. So \Bdv[1] wins exactly if \Bdv[2] and \Bdv[3] don't win their respective
%     games.

%   \item[\underline{{\Bdv[2] against collision resistance of $\hash$}}:] \Bdv[2] generates a signature keypair\\
%     $(\ssk, \spk)~\getsr~\sigkg$ and then runs $\Adv[1]$ on input $\spk$. \Bdv[2] answers signing queries using $\ssk$
%     and for all signing queries $(k^{(i)}, \vec{m}^{(i)}, \rdclass^{(i)})$ records
%     $(\vec{m}^{(i)}, \sigma^{(i)} = (\sigma'^{(i)}, \mtag^{(i)}, \accValue^{(i)}), h^{(i)}, \ell^{(i)})$ in a list $L$,
%     where $\sigma^{(i)}$ is the reducible signature and $h^{(i)}$ is the signed hash. When \Adv[1] outputs a forgery
%     $(\vec{m}^*, \sigma^* = (\sigma'^*, \mtag^*, \accValue^*(,\accProof^*, h_{j^*}^*)), k^*, \spk^*, \rd^* = (\ell^*,
%     i^*,j^*)$, \Bdv[2] recomputes $h^* = \hash(\ell^*,\accValue, \hat h^*)$ as in the verification algorithm and checks
%     its list $L$ for a corresponding pair $(\vec{m},(\sigma', \mtag,\accValue), h^*, \ell)$ with the same signed hash
%     $h^*$. If none is found, \Adv[1] produced a signature forgery and \Bdv[2] aborts (in this case, \Bdv[1] would
%     win). So assume there is such a pair.

%     If $\accValue = \accValue^*$ and $\ell = \ell^*$ and $\vec m[i] = \vec m^*[i]$ for $2\leq i \leq \ell$, then \Adv[1]
%     produced and accumulator forgery and \Bdv[2] aborts. Note that \Bdv[3] is successful in this case.

%     So assume that $\accValue \neq \accValue^*$ or $\hat h^*\neq \hat h$, i.e. the final hash in the chain differs. Then
%     $(l, \accValue, \hat h), (\ell^*, \accValue^*,\hat h^*)$ is a collision in $\hash$ and \Bdv[2] wins.

%     Now assume that $\accValue = \accValue^*$ and $\hat h^*\neq \hat h$ but there exists an $i > 1$ s.t.
%     $\vec m^*[i] \neq \vec m[i]$. Then there exists an $i^*\leq i$ s.t.
%     $\hash(\vec m[i^*],\hat h) = \hash(\vec m^*[i^*],\hat h^*)$ but $\hat h^* \neq \hat h$ or
%     $\vec m^*[i^*] \neq \vec m[i^*]$, which again yields a collision in $\hash$. Note that said $i^*$ necessarily exists
%     since we assume that $\hat h$ and $\hat h^*$ coincide before the computation of the signed hash $h^*$.
%   \item[\underline{{\Bdv[3] against unforgeability of \acc}:}] \Bdv[3] generates a signature key pair
%     $(\ssk, \spk)\getsr\sigkg$ and then calls \Adv[1] on input $\spk$. Signing queries by \Adv[1] are answered honestly
%     with the signature key \ssk and for every signing query, \Bdv[3] records the pairs
%     $(\vec{m}^{(i)}, \accValue^{(i)})$ in a list $L$.

%     Eventually, \Adv[1] outputs a forgery $\vec m^* = (m_1^*,m_2^*,\ldots,m_{j^*+1}^*)$, \\$\sigma^* = (\sigma'^*,
%     \mtag^*, \accValue^*, \accProof^*, h_{j^*}^*), k^*, \spk^*, \rd^* = (\ell^*, i^*,
%     j^*))$. We assume that \Adv[1] didn't output a signature forgery or found a hash collision, because in those cases,
%     \Bdv[1] and \Bdv[2] win their respective games. Therefore, there exists an $t^*$ s.t. $\accValue^{(t^*)} =
%     \accValue^*$. Since no hash collision occurred, $\vec m^{(t^*)}[j] = \vec m^*[j]$ for $j \geq
%     \ell^*$ but since \Adv[1] produced a valid forgery, $\vec m^{(t^*)}[i^*]\neq \vec m^*[i^*]$, because otherwise $\vec
%     m^*$ would be a valid reduction from $\vec m^{(t^*)}$. \Adv[1]'s forgery can only be valid if the accumulator proof
%     verifies and then $\vec m^{(t^*)}, \vec m^*[i^*], \accProof^*$ is a valid accumulator forgery.
%   \end{itemize}
%   It is easy to check that in every case one of the adversaries \Bdv[1],\Bdv[2], \Bdv[3] aborts, another would win. So
%   we can bound the success probability of \Adv by the sum of their success probabilities.

%   For \Adv[2], we replace all generations of asymmetric signing keys with sampling a symmetric key and replacing the
%   first adversary with one against the MAC, which works in exactly the same way.
% \end{proof}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
