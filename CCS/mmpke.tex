% !TEX root = main.tex
% !TeX spellcheck = en_US
\section{Multi-Message Multi-Recipient PKE}\label{sec:mmpke}
%\subsection{Syntax}
We first recall the syntax of mmPKE from \cite{PKC:BelBolSta03}. At a high level, mmPKE is standard encryption that
supports batching a number of encryption operations together, in order to improve efficiency.\footnote{The majority of
  works on mmPKE uses a different syntax, where there is no $\mmpkeExt$ and instead $\mmpkeEnc$ outputs a vector of
  individual ciphertexts. Since $\mmpkeExt$ is deterministic, the syntaxes are equivalent.}% However, our multi-recipient ciphertext $C$ may be shorter than a vector of individual ciphertexts.}
%
%Next, we define \emph{Multi-Recipient Multi-Message Public Key Encryption(mmPKE)}(\cite{IEEE:BelBolKur07, ASIACCS:PinPoeSch14}), which allows a sender to efficiently send a set of messages to a set of receivers with less overhead than simply using regular public key encryption in parallel.
%
\begin{definition}[\mmPKE]
  A Multi-Message Multi-Receiver Public Key Encryption (mmPKE) scheme $\mmPKE = \allowbreak(\mmpkeKeyGen,\allowbreak \mmpkeEnc,\allowbreak \mmpkeDec, \mmpkeExt)$ consists of the following four algorithms:
  \begin{description}[align=left, nosep]
  \item[]$\mmpkeKeyGen \getsl (\mmpkepk, \mmpkesk)$: Generates a new key pair.
  \item[]$\mmpkeEnc(\vec{\mmpkepk}, \vec{m})\getsl C$: On input of a vector of
    public keys $\vec{\mmpkepk}$ and a vector of messages $\vec{m}$ of the same length, it outputs a \emph{multi-recipient ciphertext} $C$ encrypting each message in $\vec{m}$ to the corresponding key in $\vec{\mmpkepk}$.
  \item[]$\mmpkeExt(C, i)\rightarrow c_i$: A deterministic function. On input a multi-recipient ciphertext $C$ and a position index $i$, outputs an \emph{individual ciphertext} $c_i$ for the $i$-th recipient.
  \item[]$\mmpkeDec(\mmpkesk,c)\rightarrow m\vee\bot$: On input of an individual ciphertext $c$ and a secret key $\mmpkesk$, outputs either the decrypted message $m$ or, in case decryption fails, $\bot$.
  \end{description}
\end{definition}
%Note that in comparison to Broadcast Encryption, mmPKE allows for different ciphertexts to different users and doesn't require a joint key generation or a common reference string.

\subsection{Security with Adaptive Corruptions}
Our security notion for \mmPKE requires indistinguishability in the presence of active adversaries who can adaptively corrupt secret keys of recipients. The notion builds upon the (strengthened) IND-CCA security of \mmPKE from \cite{ASIACCS:PinPoeSch14}, but there are two important differences: First, \cite{ASIACCS:PinPoeSch14} does not consider corruptions. Second, instead of CCA, we define the slightly weaker notion of Replayable CCA (RCCA). Roughly, RCCA \cite{C:CanKraNie03} is the same as CCA except modifying a ciphertext so that it encrypts the exact same message is not considered an attack. RCCA security is implied by CCA security.

We note that an almost identical security definition was presented in parallel by Hashimoto
et.al.\cite{hashimoto2021cmpke}. However, they only consider multi-recipient PKE (mPKE), where all
recipients receive the same message.

Our security notion is called \mmindrcca and is similar to
RCCA security of regular encryption in the multi-user setting. The main difference is that the challenge ciphertext is computed by encrypting one of two \emph{vectors} of messages $\vec m_0^*$ and $\vec m_1^*$ under a \emph{vector} of public keys $\vec\mmpkepk^*$.
The vector $\vec\mmpkepk^*$ is chosen by the adversary and can contain keys generated by the challenger as well as
arbitrary keys. The adversary also gets access to standard decrypt and corrupt oracles for each recipient.
%
To disable trivial wins, we require that  $\vec m_0^*$ and $\vec m_1^*$ have equal lengths and that if the $i$-th key in $\vec\mmpkepk^*$ is corrupted, then the $i$-th components of $\vec m_0^*$ and $\vec m_1^*$ are identical. Moreover, we require that the for each $i$, the lengths of the $i$-th components of  $\vec m_0^*$ and $\vec m_1^*$ are the same.

The last requirement means that a secure mmPKE scheme may leak the lengths of components of encrypted vectors. We note that \saik is also secure when instantiated with an mmPKE scheme that leaks more (see \cref{sec:mmowrcca}), e.g. whether two messages in a vector are the same.
%
%
% for other schemes it might include
%whether two consecutive messages are identical (the latter is still sufficient for \saik, cee \cref{sec:mmowrcca}).
%
The formal definitions are in \cref{app:mmpke}.
% whenever a key in $\vec\mmpkepk^*$ is generated by the adversary or corrupted, the corresponding messages in $\vec m_0^*$ and $\vec m_1^*$ must be the same. Moreover, the decryption oracle for receiver $i$ outputs a special symbol \literal{test} if the plaintext is receiver $i$'s message in either $\vec m_0^*$ or $\vec m_1^*$ (this is the standard way to define RCCA).

% Finally, the notion is parameterized by the leakage function $\leak(\vec m)$ which formalizes information about a vector $\vec m$ leaked by the encryption function. In this work, we only use the standard leakage that would result from using regular encryption in parallel, that is, $\leak(\vec m)$ outputs the length of each element of $\vec m$.
% However, we note that \saik is still secure if \mmPKE leaks more information, such as relations between elements of $\vec m$ (formally, one-way RCCA is implied even by \mmindrcca with larger leakage; see \cref{sec:mmowrcca}).

\subsection{Construction}
The mmPKE of~\cite{ASIACCS:PinPoeSch14} is straightforward. It requires a
data encapsulation scheme $\dem$, a hash $H$ and a group $\Grp$ of prime order $p$ generated by $g$.\footnote{In \saik we can instantiate $\dem$ with an off-the-shelf
AEAD such as AES-GCM and $H$ with HKDF.} Recall that
ElGamal encryption of $m$ to public key $g^x$ requires sampling coins $r$ to
obtain ciphertext $(g^r, \dem(k_m, m))$ where $k_m = H(g^{rx}, g^x)$. The
mmPKE variant reuses coins $r$ from the first ElGamal ciphertext to encrypt
all subsequent plaintexts. Thus, the final ciphertext has the form $(g^r,
\dem(k_1, m_1), \dem(k_2, m_2),$ $\ldots)$ where $k_i = H(g^{rx_i},
g^{x_i})$ for all $i$. We call the construction $\dhmmpke[\Grp,\allowbreak g,\allowbreak p,\allowbreak \dem, H]$; a formal description is in \cref{sec:app-mmpke}.

\paragraph{Optimizing for Short Messages.}
Normally, when messages $m$ can have arbitrary size, a sensible mmPKE would use a
KEM{\textbackslash}DEM style construction to avoid having to re-encrypt $m$
multiple times. In other words, for each $m$ in the encrypted vector, we choose a fresh key $k'_m$
for an AEAD and encrypt $m$ with $k'_m$. Then use the mmPKE of
\cite{ASIACCS:PinPoeSch14} to encrypt $k'_m$ to each public key receiving $m$.
However, since the secrets encrypted in \saik have the same length as AEAD
keys, in our case it is more efficient to encrypt the secrets directly.

%The work \cite{ASIACCS:PinPoeSch14} proves that IND-CCA security of \dhmmpke tightly reduces to the \sdh assumption.
%\dhmmpke is \mmindrcca secure \emph{with adaptive corruptions}, which follows from the result of
%\cite{ASIACCS:PinPoeSch14} with a standard argument (i.e. guessing the uncorrupted key). In \cref{sec:app-mmpke}, we
%give a tighter proof independent of the total number of public keys. The result is stated in the following \cref{thm:mmpke_security}.

\paragraph{Tight security bound.}
In \cref{sec:app-mmpke}, we prove the following upper bound on the advantage of any adversary against the \mmPKE from \cite{ASIACCS:PinPoeSch14}. Our bound is tighter than the bound that follows from the straightforward adaptation of the bound from \cite{ASIACCS:PinPoeSch14} (i.e. using the hybrid argument and guessing the uncorrupted key). In particular, that bound would depend (linearly) on the total number of public keys, which may get very large. In contrast, our bound depends only on the number of corrupted keys and the length of encrypted vectors.

\begin{restatable}{theorem}{mmpkeSecurity}\label{thm:mmpke_security}
  Let $\Grp$ be a group of prime order $p$ with generator $g$, let $\dem$ be a data encapsulation mechanism and let
  $\mmPKE = \dhmmpke[\Grp, g, p, \dem, H]$. For any adversary $\Adv$ and any $N \in \N$, there exist adversaries $\Bdv[1]$ and $\Bdv[2]$ with runtime roughly the same as $\Adv$'s s.t.
  \begin{align*}
    \textnormal{Adv}^{\mmindrcca}_{\mmPKE, N}(& \Adv) \leq \adv{\indrcca}{\dem}({\Bdv[2]}) \\
                                              &+2n\cdot(e^2q_c \adv{\sdh}{(\Grp, g, p)}({\Bdv[1]}) + \frac{q_{d_1}}{p} + \frac{q_{h}}{p}),
  \end{align*}
  where $H$ is modeled as a random oracle, $e$
  is the Euler number, $n$ is the length of the challenge vector, and $q_{d_1}$, $q_c$ and $q_h$ are the number of queries to the decrypt and corrupt oracles and the random oracle, respectively.
\end{restatable}

\begin{remark}
Some practical applications of Diffie-Hellman, most notably \textsc{Curve25519} and \textsc{Curve448} \cite{rfc7748}, implement a Diffie-Hellman operation that is not exponentiation in a prime-order group. Such operations can be formalized as so-called nominal groups \cite{EC:ABHKLR21_2}. In \cref{app:nominal_groups}, we generalize and prove \cref{thm:mmpke_security} for nominal groups. In particular, this means that \dhmmpke is secure if instantiated with \textsc{Curve25519} and \textsc{Curve448}.
\end{remark}

% We only give a proof intuition, which focuses on a technique for getting tighter security with corruptions. See \cref{sec:app-mmpke} for a full proof.
% \begin{proof}[Intuition]
%   The proof proceeds in a sequence of game hops. We start with $G_0$, which is the \mmindrcca experiment with the bit $b=0$. Then, in $G_1$ to $G_n$ we switch the elements of the message vector encrypted by the challenger from elements of $\vec m_0^*$ to elements of $\vec m_1^*$, one by one. $G_n$ is the \mmindrcca experiment with $b=1$.

%   Consider the first hop $G_1$ where the vector $(\vec m_1^*[1], \vec m_0^*[2], \dots, \vec m_0^*[n])$ is encrypted by the challenger. To show that $G_0$ and $G_1$ are indistinguishable, we define two additional hops: First, $G_{0.1}$ is the same as $G_0$ except if $\vec m_0^*[1]\neq\vec m_1^*[1]$, then the \dem key $k^*$ used to encrypt $\vec m_0^*[1]$ is random and independent. Second, $G_{0.2}$ is the same as $G_{0.1}$ except if $\vec m_0^*[1]\neq\vec m_1^*[1]$, then $\vec m_1^*[1]$ is encrypted under \dem instead of $\vec m_0^*[1]$.

%   Distinguishing between $G_{0.1}$ and $G_{0.2}$ can be easily reduced to \dem security. Observe that the difference between $G_{0.2}$ and $G_1$ is the same as between $G_0$ and $G_{0.1}$: $k^*$ is random in $G_{0.2}$ and real in $G_1$.
%   Therefore, it is left to show that $G_0$ and $G_{0.1}$ are indistinguishable.

%   Let $\Adv$ be any adversary playing $G_0$ or $G_{0.1}$. $\Adv$'s distinguishing advantage is upper-bounded by the probability that it inputs to the RO the pre-image of $k^*$. We call this event $\variable{E}$. We next construct a reduction $\Bdv$ who wins if $\variable{E}$ and some other independent events occur in the experiment with $\Adv$ and $G_0$.

%   $\Bdv$ is given an \sdh instance $X=g^x$ and $Y=g^y$ and tries to find $Z=g^{xy}$. It runs $\Adv$ and embeds $Y$ in multiple keys created by $G_0$ using self-reducability: some $\mmpkepk_i$'s are \emph{unknown}, i.e., set to $Y^{a_i}$ for random $a_i$, and some $\mmpkepk_i$'s are \emph{known}, i.e., set to $g^{a_i}$ for random $a_i$. Further, $\Bdv$ embeds $X$ as the component $c_0^*$ of the challenge ciphertext $C^*$. The decrypt oracle is simulated using the \sdh oracles in the standard way (see \cref{sec:app-mmpke}).

%   We claim that if 1) only known keys are corrupted, 2) the public key of the first recipient of $C^*$ is unknown and 3) $\variable{E}$ occurs, then $\Bdv$ wins. Indeed, 1) ensures that $\Bdv$ can simulate the corrupt oracle. Further, 2) means that the hash pre-mage of $k^*$ is implicitly set to a value containing $Z$. 3) guarantees that $\Adv$ inputs this value to the RO, which means that $\Bdv$ wins.
%   To maximize the probability of 1) and 2), $\Bdv$ makes each key known with some fixed probability $p$. One can verify that for $p=1/q_c$, the probability of 1) and 2) is highest, namely $1/(e^2q_c)$. (This technique is inspired by Coron \cite{C:Coron00}.)
% \end{proof}

% \begin{remark}
%   The work \cite{ASIACCS:PinPoeSch14} proves that \dhmmpke is tightly \mmindcca secure without corruptions, under the same assumptions as ours. However, their tight security reduction breaks if corruptions are allowed (technically, the reason is that they make all keys ``unknown''; see the proof sketch above). A straightforward fix (making exactly one key ``unknown'') would result in a security loss linear in $N$. The security loss of our reduction is independent of $N$ but still larger than in \cite{ASIACCS:PinPoeSch14} (technically, we choose the optimal number of ``unknown'' keys).
% \end{remark}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
