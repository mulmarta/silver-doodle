% !TEX root = main.tex
% !TeX spellcheck = en_US

% Continuous Group Key Agreement (CGKA), also called Group Ratcheting, lies at
% the heart of a new generation of End-to-End (E2E) secure group messaging
% (SGM) protocols supporting very large groups. The communication model,
% efficiency and security of these SGM protocols is inherited from their
% underlying CGKA protocol. In particular, a primary cost limiting practically
% viable group sizes is the communication complexity of certain CGKA
% operations.

\section{Introduction}
End-to-end (E2E) secure applications have become one of the most widely used
class of cryptographic applications on the internet with billions of daily
users. Accordingly, the E2E protocols upon which these applications are built
have evolved over several distinct generations, adding functionality and new
security guarantees along the way. Modern protocols are generally expected to
support features like multi-device accounts, continuous refreshing of secrets
and asynchronous communication. Here, \emph{asynchronous} refers to the
property that parties can communicate even when they are not simultaneously
online. To make this possible, the network provides an (untrusted) mailboxing
service for buffering packets until recipients come online.

The growing demand for E2E security motivates increasingly capable E2E
protocols; in particular, supporting ever larger groups. For example, in the
enterprise setting organizations regularly have natural sub-divisions with
far more members than practically supported by today's real-world E2E
protocols. Support for large groups opens the door to entirely new
applications; especially in the realm of machine-to-machine communication
such as in mesh networks and IoT. The desire for large groups is compounded
by the fact that many applications treat each device registered to an account
as a separate party at the E2E protocol level. For example, a private chat
between Alice and Bob who each have a phone and laptop registered to their
accounts is actually a 4-party chat from the point of view of the underlying
E2E protocol.

\paragraph{Next Generation E2E Protocols.}
The main reason current protocols (at least those enjoying state-of-the-art
security, {e.g. post compromise forward security}) only support small groups
is that their communication cost grows linearly in the group size. This
has imposed limits on real-world group sizes (generally at or below
1000 members).

Consequently, a new generation of E2E protocols is being developed both in
academia (e.g.~%
%\cite{IST-MLS-papers,ETHZ-MLS-papers,Continous-CGKA-papers}
\cite{CCS:CCGMM18,EC:AlwCorDod19,TCC:ACJM20,EPRINT:AlwJosMul20,C:ACDT20,TCC:AABNKPPW21,SP:ACC+21,hashimoto2021cmpke})
and industry~\cite{MLS}. Their primary design goal is to support extremely
large groups (e.g. 10s of thousands of users) while still meeting, or
exceeding, the security and functionality of today's state-of-the-art
deployed E2E protocols. Technically, the new protocols do this by reducing
their communication complexity to \emph{logarithmic} in the group size;
albeit, only under favorable conditions in the execution. This informal
property is sometimes termed the \emph{fair-weather complexity}. % of a
protocol.

To date, the most important of these new E2E protocols is the IETF's upcoming
secure group messaging (SGM) standard called the \emph{Messaging Layer
Security} (MLS) protocol.
% It is the product of a collaboration between
% industry practitioners and academic cryptographers.
% including Amazon, Cisco, Cloudlfare, Facebook, Mozilla,
% Twitter, Wickr and Wire and academic cryptographers (e.g. from Alto
% University, IST Austria, INRIA, MIT, Naval Postgraduate School, Oxford and
% Royal Holloway).
MLS is in the final stages of standardization and its core
components are already seeing initial deployment~\cite{Cisco-Webex-MLS}.

\paragraph{Continuous Group Key Agreement.}
To the best of our knowledge, all next gen. E2E protocols share the following
basic design paradigm. At their core lies a \emph{Continuous Group Key
Agreement} (CGKA) protocol; a generalization to the group setting of the
\emph{Continuous Key Agreement} 2-party
primitive~\cite{EC:AlwCorDod19,CSCML:DG19} underlying the Double Ratchet.

Intuitively, a CGKA protocol provides \emph{E2E secure group management} for
dynamic groups, i.e., groups whose properties may change mid-session. By
properties we mean things like the set of members currently in the group,
their attributes, the group name, the set of moderators, etc. Any change to a
group's properties initiates a fresh \emph{epoch} in the session. A CGKA
protocol ensures all group members in an epoch agree on the group's current
properties. Members will only transition to the same next epoch if they agree
on which properties were changed and by whom. Each epoch is equipped with its
own symmetric \emph{epoch key} known to all epoch members but
indistinguishable from random to anyone else. Higher-level protocols
typically (deterministically) expand the epoch key into a complete key
schedule which in turn can be used to, say, protect application data sent
between members (e.g. messages or VoiP data).
% \footnote{E.g. many CGKAs also ensure agreement about the sequence of changes
% making up the groups history. In contrast, \emph{concurrent} CGKAs ``only''
% ensure agreement on the \emph{set} of changes making up the
% history.~\cite{ConcurrentCGKAs} The new CGKAs in this work ensure agreement
% on the sequence of changes.}
% Moreover, the communication and computational complexity of the underlying
% CGKA typically dominates the complexity of the higher-level E2E protocol (and
% even the entire E2E secure application).
%  \msnote{does this fit? I somehow needed a link with the previous paragraph}

MLS too, is (implicitly) based on a CGKA, originally dubbed
\emph{TreeKEM}~\cite{TreeKEM}. Since its inception, TreeKEM has undergone several
substantial
revisions~\cite{TreeKEM-with-blanking-email,TreeKEM-prop-and-comm-email}
before reaching its current
form~\cite{mls-protocol-latest,EPRINT:AlwJosMul20}. For clarity, we refer to
its current version at the time of this writing as \emph{Insider-Secure
TreeKEM} (\protITK) (using the terminology of~\cite{EPRINT:AlwJosMul20} where
that version was analyzed). \protITK has already seen its first real world
deployment as a core component of Cisco's Webex conferencing
protocol~\cite{Cisco-Webex-MLS}.

\paragraph{Why Consider CGKA?}
CGKA is interesting because of the following two observations. First, CGKA
seems to be the minimal functionality encapsulating almost all of the
cryptographic challenges inherent to building next generation E2E protocols.
Second, building typical higher-level E2E applications (e.g. SGM or
conference calling) from a CGKA can be done via relatively generic, and
comparatively straightforward mechanisms. Moreover, the resulting application
directly inherits many of its key properties from the underlying CGKA;
notably their security guarantees and their communication and computational
complexities. In this regard, CGKA is to, say, SGM what a KEM is to hybrid
PKE. For the case of SGM, this intuitive paradigm and the relationship
between properties of the CGKA and resulting SGM was made formal
in~\cite{CCS:ACDT21}. In particular, that work abstracts and generalizes
MLS's construction from \protITK.

\subsection{Our Contributions}
This work makes progress on the central challenge in CGKA protocol design:
reducing communication complexity so as to support larger groups (without
compromising on security or functionality).

\paragraph{Server-Aided CGKA.}
We begin by revisiting one of the most basic assumptions about
CGKA in prior work; namely that participants communicate via an insecure
broadcast channel. Instead, we note that in almost all modern deployments of
E2E protocols parties actually communicate via an untrusted mailboxing
service implemented using an (often highly scalable) \emph{server}.
In light of this, we modify the standard communication model to make the
server explicit. We define a generalization of CGKA 
called \emph{server-aided} CGKA (saCGKA). In contrast to CGKA, an saCGKA
protocol includes an \emph{Extract} procedure run by the server to convert a
``full packet'' uploaded by a sender into an individualized ``sub-packet'' for a particular recipient.
 CGKA corresponds to
the special case where the full and individual packets are the same.
Intuitively, the server remains untrusted and security should hold no matter
what it does. However, should it choose to follow the Extract procedure, the
saCGKA protocol additionally ensures correctness and availability.


\paragraph{Security for CGKA.}
We define a new security notion for (sa)CGKA capturing the same intuitive
guarantees as those shown for \protITK~\cite{EPRINT:AlwJosMul20} for example.
Like other notions based on the history graph paradigm of~\cite{CCS:ACDT21},
our notion is parameterized by \emph{safety} predicates that together decide
the security of a given epoch key in a given execution.

However, at a technical level our notion departs significantly from past
ones. Essentially, it relaxes the requirement that group members in an epoch
agree on and authenticate the \emph{history of network traffic} leading to
the epoch. Instead, the new notion ``only'' ensures they agree on and
authenticate the \emph{semantics} of the history; i.e. the ``meaning'' of the
traffic rather than exact packet contents. This has several interesting
consequences. First, it more directly captures our intuitive security goals.
E.g. it avoids subtle questions about what intuition is really captured when,
say, an AEAD ciphertext in a packet can be decrypted to different plaintexts
using different keys.\footnote{This can happen for widely used AEADs like
AES-GCM~\cite{C:DGRW18}.
%This observation is also the reason why, if working in the mode with
%encrypted control packets, MLS uses the plaintext not ciphertext for the
%transcript hash. This technique is inspired by TLS 1.3.
} Second, the relaxation creates wiggle
room we can use to prove security despite group members no longer having the
same view of network traffic. Finally, it allows us to relax the security of
the encryption scheme used in our construction from CCA to
\emph{replayable CCA} (RCCA)~\cite{C:CanKraNie03}.\footnote{This makes sense
as RCCA was designed to relax the ``syntactic non-malleability`` of CCA to a
form of ``semantic non-malleability''.}

Further, the new saCGKA security notion is significantly simpler (though just as
precise) compared to past ones. Indeed, past notions have been criticised for being
all but inaccessible to non-domain experts due to their complexity. In an
effort to improve this, our new notion omits/simplifies various security
features of a CGKA as long as A) they can be formalized using known
techniques and B) they can be easily achieved by known, practical and
straightforward extensions of a generic CGKA protocol (including \saik)
satisfying our notion. Thus we obtain a definition focused on the basic
properties of an (sa)CGKA with the idea that a protocol satisfying our notion
can easily be extended to a ``full-fledged'' (sa)CGKA using standard
techniques.

\paragraph{The \saik Protocol.}
Next, we introduce a new saCGKA protocol called
\emph{Server-Aided \protITK} (\saik), designed for real-world use.
For example, it relies exclusively on standard cryptographic primitives and
can be implemented using the API of various off-the-shelf cryptographic
libraries. To obtain \saik, we start with \protITK and make the following
modifications.

\paragraph{Multi-message multi-recipient PKE.} First, we
replace \protITK's use of standard (CCA secure) PKE by multi-message
multi-recipient PKE (mmPKE)~\cite{ASIACCS:PinPoeSch14}.
mmPKE has the functionality of a parallel composition of standard PKE
schemes (both in terms of ciphertext sizes and computation cost of encryption).
Constructing mmPKE directly  can result in a significantly more efficient
scheme.

We introduce a new security notion for mmPKE, more aligned with the needs of
(the security targeted by) \saik. It both strengthens and weakens past
notions: On the one hand, proving \saik secure demands that we equip the
mmPKE adversary of~\cite{ASIACCS:PinPoeSch14} with adaptive key compromise
capabilities. On the other hand, thanks to the relaxation to semantic
agreement, we ``only'' require RCCA
security rather than full-blown CCA used in previous'
works~\cite{TCC:ACJM20,EPRINT:AlwJosMul20}.

We prove that the mmPKE construction of~\cite{ASIACCS:PinPoeSch14} satisfies our
new notion based on a form of gap Diffie-Hellman assumption, the same as in
\cite{ASIACCS:PinPoeSch14}. The reduction is tight in that the security loss
is independent of the number of parties (i.e. key pairs) in the execution
(although it does depend on the number of corrupted key pairs). Moreover, we
extend the proof to capture mmPKE constructions based on ``nominal
groups''~\cite{EC:ABHKLR21_2}. Nominal groups abstract the algebraic
structure over bit-strings implicit to the X25519 and X448 scalar
multiplication functions and corresponding twisted Edwards
curves.\cite{rfc7748}. In practical terms, this means our proofs also apply
to instantiations of~\cite{ASIACCS:PinPoeSch14} based on the X25519
and X448 functions.

%\paragraph{Authentication and Agreement.}
\paragraph{Authentication.}
Second, we modify the mechanisms used by \protITK to ensure members
transitioning to a new epoch authenticate the sender announcing a new epoch.
Rather than sign the full packet like in \protITK, the sender in \saik only
signs a small tag which ``binds`` all properties of the new epoch's, i.e., its
secrets, the set of group members, the history of applied operations, etc.
In fact, we use a tag that already exist in \protITK (called the 
``confirmation tag'').

%Second, we modify the mechanisms used by \protITK to ensure members
%transitioning to a new epoch authenticate who is making changes to the
%group's properties when a new epoch is announced. Rather than sign the full
%packet like in \protITK, a sender in \saik only signs a small tag common to
%view of all receivers. This reduces the amount of data receivers must
%download to verify the signature. We also modify how changes to the group's
%properties are incorporated in the derivation of the new epoch key. Rather
%include a hash of the full packet representing the change, \saik uses a hash
%of a symbolic representation of the change. Proving this secure leverages the
%new wiggle room in our CGKA security created by introducing semantic
%agreement.
%


\paragraph{Performance Evaluation.}
Finally, we compare the communication complexity of \saik, \protITK and the CGKA of \cite{hashimoto2021cmpke} called \protCMPKE. More precisely, we break down the communication cost into sender and receiver bandwidth, i.e., the size of a packet uploaded, resp., downloaded (by one receiver) from the server.
%
Our estimates confirm that \saik is the best CGKA in terms of sender bandwidth. Specifically, for 10K parties, \saik decreases the bandwidth of \protITK from 4.4KB down to 3.6KB for the best-case history of group evolution (but independently from the receiver) and from 1.5MB to 0.8MB for the worst-case history. Meanwhile, \protCMPKE requires 0.8MB in all cases.

For receivers, \protCMPKE achieves the smallest bandwidth that is independent of the group size. \saik is slightly worse with the receiver cost growing logarithmically in the group size. \protITK is overwhelmingly worse, as its receiver bandwidth scales between logarithmically and linearly in the group size, depending on group history. Specifically, this means that for 10K parties the receiver cost is 0.8KB for \protCMPKE, 2KB for \saik, and anywhere between 3.3KB and 1.4MB for \protITK. We note that the cost for \protITK is linear in natural scenarios, e.g., in a freshly created group.


%Finally, we provide empirical data comparing the communication complexity for
%senders and receivers running various instantiations of \saik and \protITK
%for a variety of execution profiles. Our results show that for senders, \saik
%reduces communication complexity (and halves the number of public key
%operations) compared to \protITK. Specifically, for 10K parties, sender
%communication complexity decreases from 4.4KB down to 3.6KB in the best case
%and from 1.5MB to 0.77MB in the worst case. Meanwhile for receivers the
%communication complexity goes from anywhere between logarithmic and even
%linear in the group size of \protITK down to at most logarithmic for \saik. Concretely, in a freshly created group with
%10K parties a receiver in a \protITK session needs to download 1.38MB to transition into a
%new epoch while the same receiver in \saik downloads no more than 2.7KB.

\paragraph{Outline.}
The paper is structured as follows. \cref{sec:prelims}
(and \cref{sec:addPrelim}) covers preliminaries. \cref{sec:mmpke}
focuses on mmPKE. \cref{sec:cgka} describes the new security model for
saCGKA. \cref{sec:saik} describes the \saik protocol and \cref{sec:saik-sec-int} states its security. \cref{sec:eval} contains empirical
evaluation and comparison of \saik to previous constructions. Finally, \cref{sec:ext-sec-predicates} contains extensions
to stronger security guarantees.
The formal specification of the (sa)CGKA security
model is in~\cref{sec:model}. \cref{sec:saik-details} contains a detailed description of the \saik protocol and the
security proof is formalized in \cref{sec:bgm_prot_proof}.



\subsection{Related Work}

\paragraph{Next generation CGKA protocols.}
The study of next generation CGKA protocols for very large groups was
initiated by Cohn-Gorden et al. in~\cite{CCS:CCGMM18}. This was soon followed
by the first version of TreeKEM~\cite{TreeKEM-original-email} which
evolved to add stronger
security~\cite{TreeKEM-original-email,TreeKEM-with-blanking-email,TreeKEM-tree-signing-email}
and more flexible functionality~\cite{TreeKEM-prop-and-comm-email}
culminating in its current form \protITK{}~\cite{EPRINT:AlwJosMul20}
reflected in the current draft of the MLS RFC~\cite{mls-protocol-latest}.

Reducing the communication complexity of TreeKEM and its descendants is not a
new goal. \emph{Tainted TreeKEM}~\cite{SP:ACC+21} exhibits an alternate
complexity profile optimized for a setting where the group is managed by a
small set of moderators. Recently,~\cite{TCC:AABNKPPW21} introduced new
techniques for `multi-group'' CGKAs (i.e. CGKAs that explicitly accommodate
multiple, possibly intersecting, groups) with better complexity than obtained
by running a ``single-group'' CGKA for each group. Other work has focused on
stronger security notions for CGKA both in theory~\cite{TCC:ACJM20} and with
an eye towards practice~\cite{C:ACDT20,EPRINT:AlwJosMul20}. Supporting more
concurrency has also been a topic of focus as witnessed by the protocols
in~\cite{Eprint:BDR20,TreeKEM-prop-and-comm-email,Wei19}.
Recently~\cite{EPRINT:EKNOO22} present CGKA with novel membership hiding
properties.

\paragraph{Cryptographic models of CGKA security.}
Defining CGKA security in a simple yet meaningful way has proven to be a
serious challenge. Many notions fall short in at least one of the two
following senses. Either they do not capture key guarantees desired (and
designed for) by practitioners (such as providing guarantees to newly joined
members) or they place unrealistic constraints on the adversary. Above all,
they do not consider fully active adversaries. For instance,
in~\cite{SP:ACC+21}, the adversary is not allowed to modify packets while
in~\cite{C:ACDT20,CCS:ACDT21}, new packets can be injected but only when
authenticity can be guaranteed despite past corruptions (thus limiting what
is captured about how session's regain security after corruptions).
Meanwhile, the work of~\cite{Eprint:BCK21} permits a large class of active
attacks but only in the context of the key derivation process of \protITK{}.
So while their adversaries can arbitrarily modify secrets in an honest
party's key derivation procedure, they can not deliver arbitrary packets to
honest parties. This is a significant limitation, e.g., it does not capture
adversaries that deliver packets with ciphertexts for which they do not know
the plaintexts.

Indeed, a good indication that such simplifications can be problematic can be
found in~\cite{EPRINT:AlwJosMul20}. They present an attack on TreeKEM
(that can easily be easily adapted to the CGKAs in the above works except
for~\cite{Eprint:BCK21}) which uses honest group members as decryption oracles
to clearly violate the intuitive security expected of a CGKA. Yet, each of
the above works (except for~\cite{Eprint:BCK21}) proves security of their
CGKA using only IND-CPA secure encryption.

In contrast to the above works,~\cite{TCC:ACJM20} aimed to capture the full
capabilities a realistic adversary might have. Thus, they model a fully
active adversary that can leak parties local states at will and even set
their random coins. In~\cite{EPRINT:AlwJosMul20} this setting is extended to
capture \emph{insider} security. That is adversaries which can additionally
corrupt the PKI. This captures the standard design criterion for deployed E2E
applications that key servers are \emph{not} considered trusted third
parties. Unfortunately, this level of real-world accuracy has resulted in a
(probably somewhat inherently) complicated model.

\paragraph{Symbolic models of CGKA security.}
Complementing the above line of work, several versions of TreeKEM have been
analyzed using a symbolic approach and automated provers
\cite{bhargavan:hal-02425229}. Their models consider fully active attackers
and capture relatively wide ranging security properties which the authors are
able to convincingly tackle by using automated proofs.

\paragraph{The CGKA of \cite{hashimoto2021cmpke}.}
The work \cite{hashimoto2021cmpke} presents a variant of CGKA, called here \emph{filtered} CGKA (fCGKA), along with a protocol called \protCMPKE.

In fCGKA, like in saCGKA, receivers download personalized sub-packets. However, fCGKA achieves this differently --- an uploaded fCGKA packet has a particular form, namely, a header delivered to all receivers, followed by a number of ciphertexts, one for each receiver. Note that fCGKA is a special case of saCGKA where the Extract procedure outputs the header and the receiver's ciphertext.

The fCGKA security notion in \cite{hashimoto2021cmpke} is essentially the model of \cite{EPRINT:AlwJosMul20}. The only difference is that \cite{EPRINT:AlwJosMul20} requires agreement on the history of the network packets leafing to a given epoch. To adapt this to the fCGKA syntax, \cite{hashimoto2021cmpke} requires instead agreement on the history of \emph{packet headers}. Compared to our saCGKA notion, this is still syntactic agreement and e.g., requires CCA security. See \cref{sec:semantic}.

Regarding the communication cost, the goal of \cite{hashimoto2021cmpke} is to minimize the overall cost of an operation, i.e., the size of the sent packet and all downloaded packets together. According to this metric, \protCMPKE beats both \saik and \protITK.
In contrast, in this work we look at a more fine-grained metric, namely, the cost for a single party, either the sender or a receiver. According to this metric, \protCMPKE and \saik are somewhat incomparable --- \protCMPKE is slightly better than \saik for a receiver but can be much worse for a sender. The choice of a better trade-off depends on the application.
%
We also note that, technically, the fCGKA syntax implies linear cost for the senders.

%Concurrently and independently to this work~\cite{hashimoto2021cmpke} present
%an interesting saCGKA and corresponding adaptation of the insider security
%notion of~\cite{EPRINT:AlwJosMul20}. Like our work, they consider a server
%that extracts receiver specific sub-packets from a senders full packet.
%However, their security notion still enforces representational rather than
%semantic agreement on the transcript history. They use a novel
%multi-recipient (but not multi-message) PKE which is shown to be
%post-quantum secure (though their CGKA is only proven classically secure).
%
%The efficiency of their protocol is incomparable to ours. While with \saik a
%receiver's sub-packet contains between $1$ to $\log(n)$ public keys (for
%groups of size $n$) in~\cite{hashimoto2021cmpke} a receiver never needs to
%download more than a single public key. However, both the computational and
%communication complexity for senders is \emph{always} linear in
%$n$.\footnote{In fact, this complexity is roughly a half that of a CGKA
%construction built from a network of 2-party double-ratchet channels similar
%to the sender keys protocol used by WhatsApp.} Meanwhile \saik enjoys
%logarithmic fair-weather complexity. That is, sender complexity may vary
%between linear down logarithmic (or even constant). In all but the most
%pathological executions, other than when a group is freshly created we expect
%complexity to be roughly logarithmic for the vast majority of the execution.


\paragraph{mmPKE.}
mmPKE was introduced by Kurosawa~\cite{PKC:Kurosawa02} though their
security model was flawed as pointed out and fixed by Bellare et.al
\cite{PKC:BelBolSta03,IEEE:BelBolKur07}. Yet, those works too lacked
generality as they demanded malicious receivers know a secret key for their
public key. This restriction was lifted by Poettering et.al.
in~\cite{ASIACCS:PinPoeSch14} who show that well-known PKE schemes such as
ElGamal\cite{C:ElGamal84} are secure even
when reusing coins across ciphertexts. Indeed, reusing coins this way can
also reduce the computational complexity of encapsulation and the size of
ciphertexts for KEMs as shown in the Multi-Recipient KEM (mKEM)
of~\cite{SCN:Smart04,ICICS:CLQY18a,AC:KKPP20} for example.
%which yield mmPKE via parallel execution and the KEM/DEM paradigm. Katsumata et.al. \cite{AC:KKPP20}
%claim that their mKEM constructions can be used to increase efficiency in \protITK but do not give a formal proof.
% which, similar to mmPKE, can be used to improve efficiency of \protITK.
% \msnote{I downtoned a bit -- parallel mKEM yield mmPKE but with different
% leakage. It's insecure according to \cite{ASIACCS:PinPoeSch14}.}
%
All previous security notions (for mmPKE and mKEM) allow an adversary to
provide malicious keys (with or without knowing corresponding secret keys),
but only \cite{hashimoto2021cmpke} allows for adaptive corruption of honest keys, which is necessary for
\protITK's security against adaptive adversaries.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
